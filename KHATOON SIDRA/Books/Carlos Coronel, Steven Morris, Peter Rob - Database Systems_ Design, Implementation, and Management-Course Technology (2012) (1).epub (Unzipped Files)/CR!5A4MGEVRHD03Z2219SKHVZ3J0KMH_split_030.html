<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Database Systems: Design, Implementation, and Management, Tenth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<hr class="calibre10"/><p class="calibre22"><span class="calibre35">12<a id="filepos2024073"></a>
<span><span class="calibre68">D<span><span class="calibre5">ISTRIBUTED</span></span> D<span><span class="calibre5">ATABASE</span></span> M<span><span class="calibre5">ANAGEMENT</span></span> S<span><span class="calibre5">YSTEMS</span></span></span></span></span></p>
<hr class="calibre10"/><p class="calibre9">In this chapter, you will learn:</p>
<p class="calibre45">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   About distributed database management systems (DDBMSs) and their components</p><div class="calibre3"> </div>
<p class="calibre45">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   How database implementation is affected by different levels of data and process distribution</p><div class="calibre3"> </div>
<p class="calibre45">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   How transactions are managed in a distributed database environment</p><div class="calibre3"> </div>
<p class="calibre45">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   How distributed database design draws on data partitioning and replication to balance performance, scalability, and availability</p><div class="calibre3"> </div>
<p class="calibre45">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   About the trade-offs of implementing a distributed data system</p><div class="calibre3"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre26"><span><span class="calibre27">P</span></span>review</span></p>
<hr class="calibre10"/><p class="calibre9">In this chapter, you will learn that a single database can be divided into several fragments. The fragments can be stored on different computers within a geographically dispersed network. Processing also can be dispersed among several different network sites, or nodes. The multisite database forms the core of the distributed database system.</p>
<p class="calibre9">The growth of distributed database systems has been fostered by the increased globalization of business operations, along with the rapid pace of technological change that has made distributed network-based services practical, more reliable, and cost-effective.</p>
<p class="calibre9">Although a distributed database system requires a more sophisticated DBMS, the end user should not be burdened by increased operational complexity. That is, the greater complexity of a distributed database system should be transparent to the end user.</p>
<p class="calibre9">The distributed database management system (DDBMS) treats a distributed database as a single logical database; therefore, the basic design concepts you learned in earlier chapters apply. However, although the end user need not be aware of the distributed database’s special characteristics, the distribution of data among different sites in a computer network clearly adds to the system’s complexity. For example, the design of a distributed database must consider the location of the data, the partitioning of the data into database fragments, and the replication of those fragments.</p>
<p class="calibre9">In today’s Web-centric environment, any distributed data system must be highly scalable; in other words, it must grow dynamically as demand increases. As demand grows, so do the system’s processing needs and inherent complexity. To accommodate such dynamic growth, trade-offs must be made to achieve some desirable properties.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2027874"></a>12.1 T<span><span class="calibre68">HE</span></span> E<span><span class="calibre68">VOLUTION OF</span></span> D<span><span class="calibre68">ISTRIBUTED</span></span> D<span><span class="calibre68">ATABASE</span></span> M<span><span class="calibre68">ANAGEMENT</span></span> S<span><span class="calibre68">YSTEMS</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">A <a id="filepos2028237"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2777822"><strong class="calibre14">distributed database management system (DDBMS)</strong></a> governs the storage and processing of logically related data over interconnected computer systems in which both data and processing are distributed among several sites. To understand how and why the DDBMS is different from the DBMS, it is useful to briefly examine the changes in the business environment that set the stage for the development of the DDBMS.</p>
<p class="calibre9">During the 1970s, corporations implemented centralized database management systems to meet their structured information needs. The use of a centralized database required that corporate data be stored in a single central site, usually a mainframe computer. Data access was provided through dumb terminals. The centralized approach, illustrated in <a href="#filepos2029734">Figure 12.1</a>, worked well to fill the structured information needs of corporations, but it fell short when quickly moving events required faster response times and equally quick access to information. The slow progression from information request to approval to specialist to user simply did not serve decision makers well in a dynamic environment. What was needed was quick, unstructured access to databases, using ad hoc queries to generate on-the-spot information.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2029734"></a><strong class="calibre14">FIGURE 12.1 Centralized database management system</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00464.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">The last two decades gave birth to a series of crucial social and technological changes that affected the nature of the systems and the data they use:</p>
<p class="calibre71">     •     Business operations became global; with this change, competition expanded from the shop on the next corner to the Web store in cyberspace.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Customer demands and market needs favored an on-demand transaction style, mostly based on Web-based services.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Rapid social and technological changes fueled by low-cost, smart mobile devices increased the demand for complex and fast networks to interconnect them. As a consequence, corporations have increasingly adopted advanced network technologies as the platform for their computerized solutions. See <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_034.html#filepos2380492">Chapter 14</a>, Database Connectivity and Web Technologies, for a discussion of cloud-based services.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Data realms are converging in the digital world more frequently. As a result, applications must manage multiple types of data, such as voice, video, music, and images. Such data tend to be geographically distributed and remotely accessed from diverse locations via location-aware mobile devices.</p><div class="calibre58"> </div>
<p class="calibre9">These factors created a dynamic business environment in which companies had to respond quickly to competitive and technological pressures. As large business units restructured to form leaner, quickly reacting, dispersed operations, two database requirements became obvious:</p>
<p class="calibre71">     •     <em class="italic">Rapid ad hoc data</em> access became crucial in the quick-response decision-making environment.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Distributed data access</em> was needed to support geographically dispersed business units.</p><div class="calibre58"> </div>
<p class="calibre9">During recent years, these factors became even more firmly entrenched. However, the way they were addressed was strongly influenced by the following factors:</p>
<p class="calibre71">     •     <em class="italic">The growing acceptance of the Internet as the platform for data access and distribution</em>. The World Wide Web is effectively the repository for distributed data.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">The mobile wireless revolution</em>. The widespread use of mobile wireless digital devices includes smart phones such as Apple’s iPhone and RIM’s BlackBerry and tablets such as Apple’s iPad, Motorola Xoom, and Samsung Galaxy. These devices have created high demand for data access. They access data from geographically dispersed locations and require varied data exchanges in multiple formats, such as data, voice, video, music, and pictures. Although distributed data access does not necessarily imply distributed databases, performance and failure tolerance requirements often lead to the use of data replication techniques similar to those in distributed databases.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">The accelerated growth of companies using “applications as a service.”</em> This new type of service provides remote applications to companies that want to outsource their application development, maintenance, and operations. The company data are generally stored on central servers and are not necessarily distributed. Just as with mobile data access, this type of service may not require fully distributed data functionality; however, other factors such as performance and failure tolerance often require the use of data replication techniques similar to those in distributed databases.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">The increased focus on mobile business intelligence</em>. More and more companies are embracing mobile technologies within their business plans. As companies use social networks to get closer to customers, the need for on-the-spot decision making increases. Although a data warehouse is not usually a distributed database, it does rely on techniques such as data replication and distributed queries that facilitate data extraction and integration. (You will learn more about this topic in <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_031.html#filepos2172221">Chapter 13</a>, Business Intelligence and Data Warehouses.)</p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre63"><span class="calibre35"><img alt="img" src="images/00023.jpg" class="calibre7"/> O<span><span class="calibre68">NLINE</span></span> C<span><span class="calibre68">ONTENT</span></span></span></p>
<p class="calibre9">To learn more about the Internet’s impact on data access and distribution, see <strong class="calibre14">Appendix I, Databases in Electronic Commerce</strong>, at <a href="http://www.cengagebrain.com"><em class="italic">www.cengagebrain.com</em></a>.</p>
<hr class="calibre10"/><p class="calibre9">At this point, the long-term impact of the Internet and the mobile revolution on <em class="italic">distributed</em> database design and management is just starting to be felt. Perhaps the success of the Internet and mobile technologies will foster the use of distributed databases as bandwidth becomes a less troublesome bottleneck. Perhaps the resolution of bandwidth problems will simply confirm the centralized database standard. In any case, distributed database concepts and components are likely to find a place in future database development, particularly for specialized mobile and location-aware applications.</p>
<p class="calibre9">The distributed database is especially desirable because centralized database management is subject to problems such as:</p>
<p class="calibre71">     •     <em class="italic">Performance degradation</em> because of a growing number of remote locations over greater distances</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">High costs</em> associated with maintaining and operating large central (mainframe) database systems and physical infrastructure</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Reliability problems</em> created by dependence on a central site (single point of failure syndrome) and the need for data replication</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Scalability problems</em> associated with the physical limits imposed by a single location, such as physical space, temperature conditioning, and power consumption</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Organizational rigidity</em> imposed by the database, which means it might not support the fiexibility and agility required by modern global organizations</p><div class="calibre58"> </div>
<p class="calibre9">The dynamic business environment and the centralized database’s shortcomings spawned a demand for applications based on accessing data from different sources at multiple locations. Such a multiple-source/multiple-location database environment is best managed by a DDBMS.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2037783"></a>12.2 D<span><span class="calibre68">DBMS</span></span> A<span><span class="calibre68">DVANTAGES AND</span></span> D<span><span class="calibre68">ISADVANTAGES</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Distributed database management systems deliver several advantages over traditional systems. At the same time, they are subject to some problems. <a href="#filepos2038400">Table 12.1</a> summarizes the advantages and disadvantages associated with a DDBMS.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2038400"></a><strong class="calibre14">TABLE 12.1 Distributed DBMS Advantages and Disadvantages</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<thead class="calibre77"><tr class="calibre61"><td class="calibre62"><p class="calibre63">ADVANTAGES</p></td><td class="calibre62"><p class="calibre63">DISADVANTAGES</p></td></tr></thead><tbody class="calibre60"><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Data are located near the site of greatest demand</em>. The data in a distributed database system are dispersed to match business requirements.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Complexity of management and control</em>. Applications must recognize data location, and they must be able to stitch together data from various sites. Database administrators must have the ability to coordinate database activities to prevent database degradation due to data anomalies.</span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Faster data access</em>. End users often work with only the nearest stored subset of the data.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Technological difficulty</em>. Data integrity, transaction management, concurrency control, security, backup, recovery, and query optimization must all be addressed and resolved.</span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Faster data processing</em>. A distributed database sys-tem spreads out the system’s workload by processing data at several sites.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Security</em>. The probability of security lapses increases when data are located at multiple sites. The responsibility of data management will be shared by different people at several sites.</span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Growth facilitation</em>. New sites can be added to the network without affecting the operations of other sites.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Lack of standards</em>. There are no standard com-munication protocols at the database level. For example, different database vendors employ different and often incompatible techniques to manage the distribution of data and processing in a DDBMS environment.</span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   Improved communications. Because local sites are smaller and located closer to customers, local sites foster better communication among departments and between customers and company staff.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Increased storage and infrastructure requirements</em>. Multiple copies of data are required at different sites, thus requiring additional storage space.</span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Reduced operating costs</em>. It is more cost-effective to add nodes to a network than to update a main-frame system. Development work is done more cheaply and quickly on low-cost PCs than on mainframes.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Increased training cost</em>. Training costs are generally higher in a distributed model than they would be in a centralized model, sometimes even to the extent of offsetting operational and hardware savings.</span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">User-friendly interface</em>. PCs and workstations are usually equipped with an easy-to-use graphical user interface (GUI). The GUI simplifies training and use for end users.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Costs</em>. Distributed databases require duplicated infrastructure to operate, such as physical location, environment, personnel, software, and licensing.</span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   <em class="italic">Less danger of a single-point failure</em>. When one of the computers fails, the workload is picked up by other workstations. Data are also distributed at multiple sites.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5"> </span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">•   Processor independence. The end user can access any available copy of the data, and an end user’s request is processed by any processor at the data location.</span></p><div class="calibre3"> </div></td>
<td class="calibre62"><p class="calibre95"><span class="calibre5"> </span></p><div class="calibre3"> </div></td></tr></tbody></div></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre9">Distributed databases are being used successfully in many Web staples such as Google and Amazon, but they still have a long way to go before they yield the full flexibility and power they theoretically possess.</p>
<p class="calibre9">The remainder of this chapter explores the basic components and concepts of the distributed database. Because the distributed database is usually based on the relational database model, relational terminology is used to explain the basic concepts and components. Even though some of the most widely used distributed databases are part of the NoSQL movement (see <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_012.html#filepos268583">Chapter 2</a>, Data Models), the basic concepts and fundamentals of distributed data still apply to them.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2044306"></a>12.3 D<span><span class="calibre68">ISTRIBUTED</span></span> P<span><span class="calibre68">ROCESSING AND</span></span> D<span><span class="calibre68">ISTRIBUTED</span></span> D<span><span class="calibre68">ATABASES</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">In <a id="filepos2044592"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2778485"><strong class="calibre14">distributed processing,</strong></a> a database’s logical processing is shared among two or more physically independent sites that are connected through a network. For example, the data input/output (I/O), data selection, and data validation might be performed on one computer, and a report based on that data might be created on another computer.</p>
<p class="calibre9">A basic distributed processing environment is illustrated in <a href="#filepos2045637">Figure 12.2</a>, which shows that a distributed processing system shares the database processing chores among three sites connected through a communications network. Although the database resides at only one site (Miami), each site can access the data and update the database. The database is located on Computer A, a network computer known as the <em class="italic">database server</em>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2045637"></a><strong class="calibre14">FIGURE 12.2 Distributed processing environment</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00465.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">A <a id="filepos2046036"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2777597"><strong class="calibre14">distributed database</strong></a>, on the other hand, stores a logically related database over two or more physically independent sites. The sites are connected via a computer network. In contrast, the distributed processing system uses only a single-site database but shares the processing chores among several sites. In a distributed database system, a database is composed of several parts known as <a id="filepos2046476"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2765414"><strong class="calibre14">database fragments</strong></a>. The database fragments are located at different sites and can be replicated among various sites. Each database fragment is, in turn, managed by its local database process. An example of a distributed database environment is shown in <a href="#filepos2046952">Figure 12.3</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2046952"></a><strong class="calibre14">FIGURE 12.3 Distributed database environment</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00466.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">The database in <a href="#filepos2046952">Figure 12.3</a> is divided into three database fragments (E1, E2, and E3) located at different sites. The computers are connected through a network system. In a fully distributed database, the users Alan, Betty, and Hernando do not need to know the name or location of each database fragment in order to access the database. Also, the users might be at sites other than Miami, New York, or Atlanta and still be able to access the database as a single logical unit.</p>
<p class="calibre9">As you examine <a href="#filepos2045637">Figures 12.2</a> and <a href="#filepos2046952">12.3</a>, keep the following points in mind:</p>
<p class="calibre71">     •     Distributed processing does not require a distributed database, but a distributed database requires distributed processing. (Each database fragment is managed by its own local database process.)</p><div class="calibre58"> </div>
<p class="calibre71">     •     Distributed processing may be based on a single database located on a single computer. For the management of distributed data to occur, copies or parts of the database processing functions must be distributed to all data storage sites.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Both distributed processing and distributed databases require a network of interconnected components.</p><div class="calibre58"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2048977"></a>12.4 C<span><span class="calibre68">HARACTERISTICS OF</span></span> D<span><span class="calibre68">ISTRIBUTED</span></span> D<span><span class="calibre68">ATABASE</span></span> M<span><span class="calibre68">ANAGEMENT</span></span> S<span><span class="calibre68">YSTEMS</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">A DDBMS governs the storage and processing of logically related data over interconnected computer systems in which both data and processing functions are distributed among several sites. A DBMS must have at least the following functions to be classified as distributed:</p>
<p class="calibre71">     •     <em class="italic">Application interface</em> to interact with the end user, application programs, and other DBMSs within the distributed database</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Validation</em> to analyze data requests for syntax correctness</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Transformation</em> to decompose complex requests into atomic data request components</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Query optimization</em> to find the best access strategy (which database fragments must be accessed by the query, and how must data updates, if any, be synchronized?)</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Mapping</em> to determine the data location of local and remote fragments</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">I/O interface</em> to read or write data from or to permanent local storage</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Formatting</em> to prepare the data for presentation to the end user or to an application program</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Security</em> to provide data privacy at both local and remote databases</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Backup and recovery</em> to ensure the availability and recoverability of the database in case of a failure</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">DB administration features</em> for the database administrator</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Concurrency control</em> to manage simultaneous data access and to ensure data consistency across database fragments in the DDBMS</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Transaction management</em> to ensure that the data move from one consistent state to another; this activity includes the synchronization of local and remote transactions as well as transactions across multiple distributed segments</p><div class="calibre58"> </div>
<p class="calibre9">A fully distributed database management system must perform all of the functions of a centralized DBMS, as follows:</p>
<p class="calibre81"><span class="calibre5">  1.  Receive the request of an application or end user.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  Validate, analyze, and decompose the request. The request might include mathematical and logical operations such as the following: Select all customers with a balance greater than $1,000. The request might require data from only a single table, or it might require access to several tables.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  3.  Map the request’s logical-to-physical data components.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  4.  Decompose the request into several disk I/O operations.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  5.  Search for, locate, read, and validate the data.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  6.  Ensure database consistency, security, and integrity.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  7.  Validate the data for the conditions, if any, specified by the request.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  8.  Present the selected data in the required format.</span></p><div class="calibre3"> </div>
<p class="calibre9">In addition, a distributed DBMS must handle all necessary functions imposed by the distribution of data and processing, and it must perform those additional functions <em class="italic">transparently</em> to the end user. The DDBMS’s transparent data access features are illustrated in <a href="#filepos2054034">Figure 12.4</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2054034"></a><strong class="calibre14">FIGURE 12.4 A fully distributed database management system</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00467.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">The single logical database in <a href="#filepos2054034">Figure 12.4</a> consists of two database fragments, A1 and A2, located at sites 1 and 2, respectively. Mary can query the database as if it were a local database; so can Tom. Both users “see” only one logical database and <em class="italic">do not need to know the names of the fragments</em>. In fact, the end users do not even need to know that the database is divided into fragments, <em class="italic">nor do they need to know where the fragments are located</em>.</p>
<p class="calibre9">To better understand the different types of distributed database scenarios, first consider the components of the distributed database system.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2055304"></a>12.5 DDBMS C<span><span class="calibre68">OMPONENTS</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">The DDBMS must include at least the following components:</p>
<p class="calibre71">     •     <em class="italic">Computer workstations or remote devices</em> (sites or nodes) that form the network system. The distributed database system must be independent of the computer system hardware.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Network hardware and software</em> components that reside in each workstation or device. The network components allow all sites to interact and exchange data. Because the components—computers, operating systems, network hardware, and so on—are likely to be supplied by different vendors, it is best to ensure that distributed database functions can be run on multiple platforms.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Communications media</em> that carry the data from one node to another. The DDBMS must be communications media-independent; that is, it must be able to support several types of communications media.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The <a id="filepos2056599"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2880826"><strong class="calibre14">transaction processor (TP)</strong></a>, which is the software component found in each computer or device that requests data. The transaction processor receives and processes the application’s remote and local data requests. The TP is also known as the <a id="filepos2056890"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2729650"><strong class="calibre14">application processor (AP)</strong></a> or the <a id="filepos2056975"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2880618"><strong class="calibre14">transaction manager (TM)</strong></a>.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The <a id="filepos2057136"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2761446"><strong class="calibre14">data processor (DP)</strong></a>, which is the software component residing on each computer or device that stores and retrieves data located at the site. The DP is also known as the <a id="filepos2057356"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2759774"><strong class="calibre14">data manager (DM)</strong></a>. A data processor may even be a centralized DBMS.</p><div class="calibre58"> </div>
<p class="calibre9"><a href="#filepos2057919">Figure 12.5</a> illustrates the placement of the components and the interaction among them. The communication among TPs and DPs is made possible through a specific set of rules, or <em class="italic">protocols</em>, used by the DDBMS.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2057919"></a><strong class="calibre14">FIGURE 12.5 Distributed database system management components</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00468.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">The protocols determine how the distributed database system will:</p>
<p class="calibre71">     •     Interface with the network to transport data and commands between DPs and TPs.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Synchronize all data received from DPs (TP side) and route retrieved data to the appropriate TPs (DP side).</p><div class="calibre58"> </div>
<p class="calibre71">     •     Ensure common database functions in a distributed system. Such functions include data security, transaction management and concurrency control, data partitioning and synchronization, and data backup and recovery.</p><div class="calibre58"> </div>
<p class="calibre9">DPs and TPs should be added to the system transparently without affecting its operation. A TP and a DP can reside on the same computer, allowing the end user to access both local and remote data transparently. In theory, a DP can be an independent centralized DBMS with proper interfaces to support remote access from other independent DBMSs in the network.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2059621"></a>12.6 L<span><span class="calibre68">EVELS OF</span></span> D<span><span class="calibre68">ATA AND</span></span> P<span><span class="calibre68">ROCESS</span></span> D<span><span class="calibre68">ISTRIBUTION</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Current database systems can be classified on the basis of how process distribution and data distribution are supported. For example, a DBMS may store data in a single site (using a centralized DB) or in multiple sites (using a distributed DB), and may support data processing at one or more sites. <a href="#filepos2060524">Table 12.2</a> uses a simple matrix to classify database systems according to data and process distribution. These types of processes are discussed in the sections that follow.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2060524"></a><strong class="calibre14">TABLE 12.2 Database Systems: Levels of Data and Process Distribution</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<thead class="calibre77"><tr class="calibre61"><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><p class="calibre63">SINGLE-SITE DATA</p></td><td class="calibre62"><p class="calibre63">MULTIPLE-SITE DATA</p></td></tr></thead><tbody class="calibre60"><tr class="calibre61"><td class="calibre62"><p class="calibre63">Single-site process</p></td><td class="calibre62"><p class="calibre63">Host DBMS</p></td><td class="calibre62"><p class="calibre63">Not applicable</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><p class="calibre63">(Requires multiple processes)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Multiple-site process</p></td><td class="calibre62"><p class="calibre63">File server</p></td><td class="calibre62"><p class="calibre63">Fully distributed</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><p class="calibre63">Client/server DBMS (LAN DBMS)</p></td><td class="calibre62"><p class="calibre63">Client/server DDBMS</p></td></tr></tbody></div></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><a id="filepos2061993"></a>12.6.1 S<span><span class="calibre5">INGLE</span></span>-S<span><span class="calibre5">ITE</span></span> P<span><span class="calibre5">ROCESSING,</span></span> S<span><span class="calibre5">INGLE</span></span>-S<span><span class="calibre5">ITE</span></span> D<span><span class="calibre5">ATA</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">In the <a id="filepos2062347"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2864121"><strong class="calibre14">single-site processing, single-site data (SPSD)</strong></a> scenario, all processing is done on a single host computer and all data are stored on the host computer’s local disk system. Processing cannot be done on the end user’s side of the system. Such a scenario is typical of most mainframe and midrange UNIX/Linux server DBMSs. The DBMS is on the host computer, which is accessed by terminals connected to it (see <a href="#filepos2063071">Figure 12.6</a>). This scenario is also typical of the first generation of single-user microcomputer databases.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2063071"></a><strong class="calibre14">FIGURE 12.6 Single-site processing, single-site data (centralized)</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00469.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Using <a href="#filepos2063071">Figure 12.6</a> as an example, you can see that the functions of the TP and DP are embedded within the DBMS on the host computer. The DBMS usually runs under a time-sharing, multitasking operating system, which allows several processes to run concurrently on a host computer accessing a single DP. All data storage and data processing are handled by a single host computer.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos2063960"></a>12.6.2 M<span><span class="calibre5">ULTIPLE</span></span>-S<span><span class="calibre5">ITE</span></span> P<span><span class="calibre5">ROCESSING</span></span>, S<span><span class="calibre5">INGLE</span></span>-S<span><span class="calibre5">ITE</span></span> D<span><span class="calibre5">ATA</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Under the <a id="filepos2064319"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2825510"><strong class="calibre14">multiple-site processing, single-site data (MPSD)</strong></a> scenario, multiple processes run on different computers that share a single data repository. Typically, the MPSD scenario requires a network file server running conventional applications that are accessed through a network. Many multiuser accounting applications running under a personal computer network fit such a description (see <a href="#filepos2066147">Figure 12.7</a>).</p>
<p class="calibre9">As you examine <a href="#filepos2066147">Figure 12.7</a>, note that:</p>
<p class="calibre71">     •     The TP on each workstation acts only as a redirector to route all network data requests to the file server.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The end user sees the file server as just another hard disk. Because only the data storage input/output (I/O) is handled by the file server’s computer, the MPSD offers limited capabilities for distributed processing.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The end user must make a direct reference to the file server to access remote data. All record- and file-locking activities are performed at the end-user location.</p><div class="calibre58"> </div>
<p class="calibre71">     •     All data selection, search, and update functions take place at the workstation, thus requiring that entire files travel through the network for processing at the workstation. Such a requirement increases network traffic, slows response time, and increases communication costs.</p><div class="calibre58"> </div>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2066147"></a><strong class="calibre14">FIGURE 12.7 Multiple-site processing, single-site data</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00470.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">The inefficiency of the last condition can be illustrated easily. For example, suppose that the file server computer stores a CUSTOMER table containing 100,000 data rows, 50 of which have balances greater than $1,000. Suppose that site A issues the following SQL query:</p>
<p class="calibre9">SELECT        *</p>
<p class="calibre9">FROM          CUSTOMER</p>
<p class="calibre9">WHERE       CUS_BALANCE &gt; 1000;</p>
<p class="calibre9">All 100,000 CUSTOMER rows must travel through the network to be evaluated at site A. A variation of the multiplesite processing, single-site data approach is known as client/server architecture. <a id="filepos2067364"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2742369"><strong class="calibre14">Client/server architecture</strong></a> is similar to that of the network file server <em class="italic">except that all database processing is done at the server site, thus reducing network traffic</em>. Although both the network file server and the client/server systems perform multiple-site processing, the latter’s processing is distributed. Note that the network file server approach requires the database to be located at a single site. In contrast, the client/server architecture is capable of supporting data at multiple sites.</p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre35"><img alt="img" src="images/00023.jpg" class="calibre7"/> O<span><span class="calibre68">NLINE</span></span> C<span><span class="calibre68">ONTENT</span></span></span></p>
<p class="calibre9"><strong class="calibre14">Appendix F, Client/Server Systems</strong>, is available at <a href="http://www.cengagebrain.com"><em class="italic">www.cengagebrain.com</em></a>.</p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><a id="filepos2068408"></a>12.6.3 M<span><span class="calibre5">ULTIPLE</span></span>-S<span><span class="calibre5">ITE</span></span> P<span><span class="calibre5">ROCESSING</span></span>, M<span><span class="calibre5">ULTIPLE</span></span>-S<span><span class="calibre5">ITE</span></span> D<span><span class="calibre5">ATA</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">The <a id="filepos2068763"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2825186"><strong class="calibre14">multiple-site processing, multiple-site data (MPMD)</strong></a> scenario describes a fully distributed DBMS with support for multiple data processors and transaction processors at multiple sites. Depending on the level of support for various types of databases, DDBMSs are classified as either homogeneous or heterogeneous.</p>
<p class="calibre9"><a id="filepos2069195"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2801381"><strong class="calibre14">Homogeneous DDBMSs</strong></a> integrate multiple instances of the same DBMS over a network—for example, multiple instances of Oracle 11g running on different platforms. In contrast, <a id="filepos2069417"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2800513"><strong class="calibre14">heterogeneous DDBMSs</strong></a> integrate different types of DBMSs over a network, but all support the same data model. For example, <a href="#filepos2070036">Table 12.3</a> lists several relational database systems that could be integrated within a DDBMS. A <a id="filepos2069713"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2796260"><strong class="calibre14">fully heterogeneous DDBMS</strong></a> will support different DBMSs, each one supporting a different data model, running under different computer systems.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2070036"></a><strong class="calibre14">TABLE 12.3 Heterogeneous Distributed Database Scenario</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00471.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre9">Distributed database implementations are better understood as an abstraction layer on top of a DBMS. This abstraction layer provides additional functionality that enables support for distributed database features, including straightforward data links, replication, advanced data fragmentation, synchronization, and integration. In fact, most database vendors provide for increasing levels of data fragmentation, replication, and integration. Therefore, the support for distributed databases can be better seen as a continuous spectrum that goes from homogeneous to fully heterogeneous distributed data management. Consequently, at any point on this spectrum, a DDBMS is subject to certain restrictions. For example:</p>
<p class="calibre71">     •     Remote access is provided on a read-only basis and does not support write privileges.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Restrictions are placed on the number of remote tables that may be accessed in a single transaction.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Restrictions are placed on the number of distinct databases that may be accessed.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Restrictions are placed on the database model that may be accessed. Thus, access may be provided to relational databases but not to network or hierarchical databases.</p><div class="calibre58"> </div>
<p class="calibre9">The preceding list of restrictions is by no means exhaustive. The DDBMS technology continues to change rapidly, and new features are added frequently. (In <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_012.html#filepos268583">Chapter 2</a>, you learned about the latest generation of NoSQL databases that provide high levels of data distribution.) Managing data at multiple sites leads to a number of issues that must be addressed and understood. The next section examines several key features of distributed database management systems.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2072492"></a>12.7 D<span><span class="calibre68">ISTRIBUTED</span></span> D<span><span class="calibre68">ATABASE</span></span> T<span><span class="calibre68">RANSPARENCY</span></span> F<span><span class="calibre68">EATURES</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">A distributed database system should provide some desirable transparency features that make all the system’s complexities hidden to the end user. In other words, the end user should have the sense of working with a centralized DBMS. For this reason, the minimum desirable DDBMS transparency features are:</p>
<p class="calibre71">     •     <a id="filepos2073154"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2779234"><strong class="calibre14">Distribution transparency</strong></a>, which allows a distributed database to be treated as a single logical database. If a DDBMS exhibits distribution transparency, the user does not need to know:</p><div class="calibre58"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    That the data are partitioned—meaning the table’s rows and columns are split vertically or horizontally and stored among multiple sites</span></p></blockquote><div class="calibre23"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    That the data are geographically dispersed among multiple sites</span></p></blockquote><div class="calibre23"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    That the data are replicated among multiple sites</span></p></blockquote><div class="calibre23"> </div>
<p class="calibre71">     •     <a id="filepos2074084"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2881287"><strong class="calibre14">Transaction transparency</strong></a>, which allows a transaction to update data at more than one network site. Transaction transparency ensures that the transaction will be either entirely completed or aborted, thus maintaining database integrity.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <a id="filepos2074451"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2792177"><strong class="calibre14">Failure transparency</strong></a>, which ensures that the system will continue to operate in the event of a node or network failure. Functions that were lost because of the failure will be picked up by another network node. This is a very important feature, particularly in organizations that depend on Web presence as the backbone for maintaining trust in their business.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <a id="filepos2074942"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2838771"><strong class="calibre14">Performance transparency,</strong></a> which allows the system to perform as if it were a centralized DBMS. The system will not suffer any performance degradation due to its use on a network or because of the network’s platform differences. Performance transparency also ensures that the system will find the most cost-effective path to access remote data. The system should be able to “scale out” in a transparent manner, or increase performance capacity by adding more transaction or data-processing nodes, without affecting the overall performance of the system.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <a id="filepos2075626"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2800277"><strong class="calibre14">Heterogeneity transparency</strong></a>, which allows the integration of several different local DBMSs (relational, network, and hierarchical) under a common, or global, schema. The DDBMS is responsible for translating the data requests from the global schema to the local DBMS schema.</p><div class="calibre58"> </div>
<p class="calibre9">The following sections discuss each of these transparency features in greater detail.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2076262"></a>12.8 D<span><span class="calibre68">ISTRIBUTION</span></span> T<span><span class="calibre68">RANSPARENCY</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Distribution transparency allows a physically dispersed database to be managed as though it were a centralized database. The level of transparency supported by the DDBMS varies from system to system. Three levels of distribution transparency are recognized:</p>
<p class="calibre71">     •     <a id="filepos2076790"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2795028"><strong class="calibre14">Fragmentation transparency</strong></a> is the highest level of transparency. The end user or programmer does not need to know that a database is partitioned. Therefore, neither fragment names nor fragment locations are specified prior to data access.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <a id="filepos2077160"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2816624"><strong class="calibre14">Location transparency</strong></a> exists when the end user or programmer must specify the database fragment names but does not need to specify where those fragments are located.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <a id="filepos2077457"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2816292"><strong class="calibre14">Local mapping transparency</strong></a> exists when the end user or programmer must specify both the fragment names and their locations.</p><div class="calibre58"> </div>
<p class="calibre9">Transparency features are summarized in <a href="#filepos2077910">Table 12.4</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2077910"></a><strong class="calibre14">TABLE 12.4 Summary of Transparency Features</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00472.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63">N<span><span class="calibre8">OTE</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre53">As you examine <a href="#filepos2077910">Table 12.4</a>, notice that there is no reference to a situation in which the fragment name is “No” and the location name is “Yes.” The reason is simple: you cannot have a location name that fails to reference an existing fragment. If you don’t need to specify a fragment name, its location is clearly irrelevant.</p></blockquote>
<hr class="calibre10"/><p class="calibre9">To illustrate the use of various transparency levels, suppose you have an EMPLOYEE table that contains the attributes EMP_NAME, EMP_DOB, EMP_ADDRESS, EMP_DEPARTMENT, and EMP_SALARY. The EMPLOYEE data are distributed over three different locations: New York, Atlanta, and Miami. The table is divided by location; that is, New York employee data are stored in fragment E1, Atlanta employee data are stored in fragment E2, and Miami employee data are stored in fragment E3 (see <a href="#filepos2080137">Figure 12.8</a>).</p>
<p class="calibre9">Now suppose that the end user wants to list all employees born before January 1, 1960. To focus on the transparency issues, also suppose that the EMPLOYEE table is fragmented and each fragment is unique. The <a id="filepos2079581"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2884973"><strong class="calibre14">unique fragment</strong></a> condition indicates that each row is unique, regardless of the fragment in which it is located. Finally, assume that no portion of the database is replicated at any other site on the network.</p>
<p class="calibre9">Depending on the level of distribution transparency support, you may examine three query cases.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2080137"></a><strong class="calibre14">FIGURE 12.8 Fragment locations</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00473.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre83"><span class="calibre5"><strong class="calibre14">Case 1: The Database Supports Fragmentation Transparency</strong></span></p>
<p class="calibre53">The query conforms to a nondistributed database query format; that is, it does not specify fragment names or locations. The query reads:</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM          EMPLOYEE</p>
<p class="calibre9">WHERE       EMP_DOB &lt; ‘01-JAN-1960’;</p>
<p class="calibre83"><span class="calibre5"><strong class="calibre14">Case 2: The Database Supports Location Transparency</strong></span></p>
<p class="calibre53">Fragment names must be specified in the query, but the fragment’s location is not specified. The query reads:</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM          E1</p>
<p class="calibre9">WHERE       EMP_DOB &lt; ‘01-JAN-1960’;</p>
<p class="calibre9">UNION</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM          E2</p>
<p class="calibre9">WHERE       EMP_DOB &lt; ‘01-JAN-1960’;</p>
<p class="calibre9">UNION</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM         E3</p>
<p class="calibre9">WHERE       EMP_DOB &lt; ‘01-JAN-1960’;</p>
<p class="calibre83"><span class="calibre5"><strong class="calibre14">Case 3: The Database Supports Local Mapping Transparency</strong></span></p>
<p class="calibre53">Both the fragment name and its location must be specified in the query. Using pseudo-SQL:</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM         El NODE NY</p>
<p class="calibre9">WHERE       EMP_DOB &lt; ‘01-JAN-1960’;</p>
<p class="calibre9">UNION</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM          E2 NODE ATL</p>
<p class="calibre9">WHERE       EMP_DOB &lt; ‘01-JAN-1960’;</p>
<p class="calibre9">UNION</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM          E3 NODE MIA</p>
<p class="calibre9">WHERE       EMP_DOB &lt; ‘01-JAN-1960’;</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63">N<span><span class="calibre8">OTE</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre53">NODE indicates the location of the database fragment. NODE is used for illustration purposes and is not part of the standard SQL syntax.</p></blockquote>
<hr class="calibre10"/><p class="calibre9">As you examine the preceding query formats, you can see how distribution transparency affects the way end users and programmers interact with the database.</p>
<p class="calibre9">Distribution transparency is supported by a <a id="filepos2084459"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2777382"><strong class="calibre14">distributed data dictionary (DDD)</strong></a> or a <a id="filepos2084549"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2777073"><strong class="calibre14">distributed data catalog (DDC)</strong></a>. The DDC contains the description of the entire database as seen by the database administrator. The database description, known as the <a id="filepos2084766"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2778247"><strong class="calibre14">distributed global schema</strong></a>, is the common database schema used by local TPs to translate user requests into subqueries (remote requests) that will be processed by different DPs. The DDC is itself distributed, and it is replicated at the network nodes. Therefore, the DDC must maintain consistency through updating at all sites.</p>
<p class="calibre9">Keep in mind that some of the current DDBMS implementations impose limitations on the level of transparency support. For instance, you might be able to distribute a database, but not a table, across multiple sites. Such a condition indicates that the DDBMS supports location transparency but not fragmentation transparency.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2085694"></a>12.9 T<span><span class="calibre68">RANSACTION</span></span> T<span><span class="calibre68">RANSPARENCY</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Transaction transparency is a DDBMS property that ensures database transactions will maintain the distributed database’s integrity and consistency. Remember that a DDBMS database transaction can update data stored in many different computers connected in a network. Transaction transparency ensures that the transaction will be completed only when all database sites involved in the transaction complete their part of the transaction.</p>
<p class="calibre9">Distributed database systems require complex mechanisms to manage transactions and ensure the database’s consistency and integrity. To understand how the transactions are managed, you should know the basic concepts governing remote requests, remote transactions, distributed transactions, and distributed requests.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos2086771"></a>12.9.1 D<span><span class="calibre5">ISTRIBUTED</span></span> R<span><span class="calibre5">EQUESTS AND</span></span> D<span><span class="calibre5">ISTRIBUTED</span></span> T<span><span class="calibre5">RANSACTIONS</span></span><sup class="calibre24"><a href="#filepos2171134">1</a></sup></span></p>
<hr class="calibre10"/><p class="calibre9">Whether or not a transaction is distributed, it is formed by one or more database requests. The basic difference between a nondistributed transaction and a distributed transaction is that the latter can update or request data from several different remote sites on a network. To better understand distributed transactions, begin by learning the difference between remote and distributed transactions, using the BEGIN WORK and COMMIT WORK transaction format. Assume the existence of location transparency to avoid having to specify the data location.</p>
<p class="calibre9">A <a id="filepos2087717"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2852369"><strong class="calibre14">remote request</strong></a>, illustrated in <a href="#filepos2088170">Figure 12.9</a>, lets a single SQL statement access the data that are to be processed by a single remote database processor. In other words, the SQL statement (or request) can reference data at only one remote site.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2088170"></a><strong class="calibre14">FIGURE 12.9 A remote request</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00474.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Similarly, a <a id="filepos2088562"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2852653"><strong class="calibre14">remote transaction</strong></a>, composed of several requests, accesses data at a single remote site. A remote transaction is illustrated in <a href="#filepos2088914">Figure 12.10</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2088914"></a><strong class="calibre14">FIGURE 12.10 A remote transaction</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00475.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">As you examine <a href="#filepos2088914">Figure 12.10</a>, note the following remote transaction features:</p>
<p class="calibre71">     •     The transaction updates the PRODUCT and INVOICE tables (located at site B).</p><div class="calibre58"> </div>
<p class="calibre71">     •     The remote transaction is sent to the remote site B and executed there.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The transaction can reference only one remote DP.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Each SQL statement (or request) can reference only one (the same) remote DP at a time, and the entire transaction can reference and be executed at only one remote DP.</p><div class="calibre58"> </div>
<p class="calibre9">A <a id="filepos2090158"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2778986"><strong class="calibre14">distributed transaction</strong></a> can reference several different local or remote DP sites. Although each single request can reference only one local or remote DP site, the transaction as a whole can reference multiple DP sites because each request can reference a different site. The distributed transaction process is illustrated in <a href="#filepos2090707">Figure 12.11</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2090707"></a><strong class="calibre14">FIGURE 12.11 A distributed transaction</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00476.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Note the following features in <a href="#filepos2090707">Figure 12.11</a>:</p>
<p class="calibre71">     •     The transaction references two remote sites, B and C.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The first two requests, UPDATE PRODUCT and INSERT INTO INVOICE, are processed by the DP at the remote site C, and the last request (UPDATE CUSTOMER) is processed by the DP at the remote site B.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Each request can access only one remote site at a time.</p><div class="calibre58"> </div>
<p class="calibre9">The third characteristic may create problems. For example, suppose the PRODUCT table is divided into two fragments, PRODl and PROD2, located at sites B and C, respectively. Given that scenario, the preceding distributed transaction cannot be executed because the following request cannot access data from more than one remote site:</p>
<p class="calibre9">SELECT       *</p>
<p class="calibre9">FROM         PRODUCT</p>
<p class="calibre9">WHERE       PROD_NUM = ‘231785’;</p>
<p class="calibre9">Therefore, the DBMS must be able to support a distributed request.</p>
<p class="calibre9">A <a id="filepos2092596"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2778715"><strong class="calibre14">distributed request</strong></a> lets a single SQL statement reference data located at several different local or remote DP sites. Because each request (SQL statement) can access data from more than one local or remote DP site, a transaction can access several sites. The ability to execute a distributed request provides fully distributed database processing because you can:</p>
<p class="calibre71">     •     Partition a database table into several fragments.</p><div class="calibre58"> </div>
<p class="calibre71">     •     Reference one or more of those fragments with only one request. In other words, there is fragmentation transparency.</p><div class="calibre58"> </div>
<p class="calibre9">The location and partition of the data should be transparent to the end user. <a href="#filepos2093884">Figure 12.12</a> illustrates a distributed request. As you examine the figure, note that the transaction uses a single SELECT statement to reference two tables, CUSTOMER and INVOICE. The two tables are located at two different sites, B and C.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2093884"></a><strong class="calibre14">FIGURE 12.12 A distributed request</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00477.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">The distributed request feature also allows a single request to reference a physically partitioned table. For example, suppose that a CUSTOMER table is divided into two fragments, C1 and C2, located at sites B and C, respectively. Further suppose that the end user wants to obtain a list of all customers whose balances exceed $250. The request is illustrated in <a href="#filepos2094909">Figure 12.13</a>. Full fragmentation transparency support is provided only by a DDBMS that supports distributed requests.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2094909"></a><strong class="calibre14">FIGURE 12.13 Another distributed request</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00478.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Understanding the different types of database requests in distributed database systems helps you address the transaction transparency issue more effectively. Transaction transparency ensures that distributed transactions are treated as centralized transactions, ensuring their serializability. (Review <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_028.html#filepos1760802">Chapter 10</a>, Transaction Management and Concurrency Control, if necessary.) That is, the execution of concurrent transactions, whether they are distributed or not, will take the database from one consistent state to another.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos2095922"></a>12.9.2 D<span><span class="calibre5">ISTRIBUTED</span></span> C<span><span class="calibre5">ONCURRENCY</span></span> C<span><span class="calibre5">ONTROL</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Concurrency control becomes especially important in distributed databases because multisite, multiple-process operations are more likely to create data inconsistencies and deadlocked transactions than single-site systems. For example, the TP component of a DDBMS must ensure that all parts of the transaction are completed at all sites before a final COMMIT is issued to record the transaction.</p>
<p class="calibre9">Suppose that a transaction updates data at three DP sites. The first two DP sites complete the transaction and commit the data at each local DP; however, the third DP site cannot commit the transaction. Such a scenario would yield an inconsistent database, with its inevitable integrity problems, because committed data cannot be uncommitted! This problem is illustrated in <a href="#filepos2097166">Figure 12.14</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2097166"></a><strong class="calibre14">FIGURE 12.14 The effect of a premature COMMIT</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00479.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">The solution to this problem is a <em class="italic">two-phase commit protocol</em>, which you will explore next.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos2097730"></a>12.9.3 T<span><span class="calibre5">WO</span></span>-P<span><span class="calibre5">HASE</span></span> C<span><span class="calibre5">OMMIT</span></span> P<span><span class="calibre5">ROTOCOL</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Centralized databases require only one DP. All database operations take place at only one site, and the consequences of database operations are immediately known to the DBMS. In contrast, distributed databases make it possible for a transaction to access data at several sites. A final COMMIT must not be issued until all sites have committed their parts of the transaction. The <a id="filepos2098371"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2882615"><strong class="calibre14">two-phase commit protocol (2PC)</strong></a> guarantees that if a portion of a transaction operation cannot be committed, all changes made at the other sites participating in the transaction will be undone to maintain a consistent database state.</p>
<p class="calibre9">Each DP maintains its own transaction log. The two-phase commit protocol requires that the transaction log entry for each DP be written before the database fragment is actually updated (see <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_028.html#filepos1760802">Chapter 10</a>). Therefore, the two-phase commit protocol requires a DO-UNDO-REDO protocol and a write-ahead protocol.</p>
<p class="calibre9">The <a id="filepos2099130"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2780039"><strong class="calibre14">DO-UNDO-REDO protocol</strong></a> is used by the DP to roll transactions back and forward with the help of the system’s transaction log entries. The DO-UNDO-REDO protocol defines three types of operations:</p>
<p class="calibre71">     •     DO performs the operation and records the “before” and “after” values in the transaction log.</p><div class="calibre58"> </div>
<p class="calibre71">     •     UNDO reverses an operation, using the log entries written by the DO portion of the sequence.</p><div class="calibre58"> </div>
<p class="calibre71">     •     REDO redoes an operation, using the log entries written by the DO portion of the sequence.</p><div class="calibre58"> </div>
<p class="calibre9">To ensure that the DO, UNDO, and REDO operations can survive a system crash while they are being executed, a write-ahead protocol is used. The <a id="filepos2100105"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2891130"><strong class="calibre14">write-ahead protocol</strong></a> forces the log entry to be written to permanent storage before the actual operation takes place.</p>
<p class="calibre9">The two-phase commit protocol defines the operations between two types of nodes: the <a id="filepos2100428"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2750016"><strong class="calibre14">coordinator</strong></a> and one or more <a id="filepos2100507"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2872172"><strong class="calibre14">subordinates</strong></a>, or <em class="italic">cohorts</em>. The participating nodes agree on a coordinator. Generally, the coordinator role is assigned to the node that initiates the transaction. However, different systems implement various, more sophisticated election methods. The protocol is implemented in two phases, as illustrated in the following sections.</p>
<p class="calibre83"><span class="calibre5"><strong class="calibre14">Phase 1: Preparation</strong></span></p>
<p class="calibre53">The coordinator sends a PREPARE TO COMMIT message to all subordinates.</p>
<p class="calibre79"><span class="calibre5">  1.  The subordinates receive the message, write the transaction log using the write-ahead protocol, and send an acknowledgment message (YES/PREPARED TO COMMIT or NO/NOT PREPARED) to the coordinator.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  The coordinator makes sure that all nodes are ready to commit, or it aborts the action.</span></p><div class="calibre3"> </div>
<p class="calibre9">If all nodes are PREPARED TO COMMIT, the transaction goes to Phase 2. If one or more nodes reply NO or NOT PREPARED, the coordinator broadcasts an ABORT message to all subordinates.</p>
<p class="calibre83"><span class="calibre5"><strong class="calibre14">Phase 2: The Final COMMIT</strong></span></p>
<p class="calibre79"><span class="calibre5">  1.  The coordinator broadcasts a COMMIT message to all subordinates and waits for the replies.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  Each subordinate receives the COMMIT message and then updates the database using the DO protocol.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  3.  The subordinates reply with a COMMITTED or NOT COMMITTED message to the coordinator.</span></p><div class="calibre3"> </div>
<p class="calibre9">If one or more subordinates do not commit, the coordinator sends an ABORT message, thereby forcing them to UNDO all changes.</p>
<p class="calibre9">The objective of the two-phase commit is to ensure that each node commits its part of the transaction; otherwise, the transaction is aborted. If one of the nodes fails to commit, the information necessary to recover the database is in the transaction log, and the database can be recovered with the DO-UNDO-REDO protocol. (Remember that the log information was updated using the write-ahead protocol.)</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2103382"></a>12.10 P<span><span class="calibre68">ERFORMANCE AND</span></span> F<span><span class="calibre68">AILURE</span></span> T<span><span class="calibre68">RANSPARENCY</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">One of the most important functions of a database is its ability to make data available. Web-based distributed data systems demand high availability, which means not only that data are accessible but that requests are processed in a timely manner. For example, the average Google search has a subsecond response time. When was the last time you entered a Google query and waited more than a couple of seconds for the results?</p>
<p class="calibre9">Performance transparency allows a DDBMS to perform as if it were a centralized database. In other words, no performance degradation should be incurred due to data distribution. Failure transparency ensures that the system will continue to operate in the case of a node or network failure. Although these are two separate issues, they are interrelated in that a failing node or congested network path could cause performance problems. Therefore, both issues are addressed in this section.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63">N<span><span class="calibre8">OTE</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre53"><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_029.html#filepos1888337">Chapter 11</a>, Database Performance Tuning and Query Optimization</strong>, provides additional details about query optimization.</p></blockquote>
<hr class="calibre10"/><p class="calibre9">The objective of query optimization is to minimize the total cost associated with the execution of a request. The costs associated with a request are a function of the following:</p>
<p class="calibre71">     •     Access time (I/O) cost involved in accessing the data from multiple remote sites</p><div class="calibre58"> </div>
<p class="calibre71">     •     Communication cost associated with data transmission among nodes in distributed database systems</p><div class="calibre58"> </div>
<p class="calibre71">     •     CPU time cost associated with the processing overhead of managing distributed transactions</p><div class="calibre58"> </div>
<p class="calibre9">Although costs are often classified either as communication or processing costs, it is difficult to separate the two. Not all query optimization algorithms use the same parameters, and not all algorithms assign the same weight to each parameter. For example, some algorithms minimize total time, others minimize the communication time, and still others do not factor in the CPU time, considering its cost insignificant relative to other costs.</p>
<p class="calibre9">As you learned in <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_029.html#filepos1888337">Chapter 11</a>, a centralized database evaluates every data request to find the most efficient way to access the data. This is a reasonable requirement, considering that all data are locally stored and all active transactions working on the data are known to the central DBMS. In contrast, in a DDBMS, transactions are distributed among multiple nodes; therefore, determining what data are being used becomes more complex. Hence, resolving data requests in a distributed data environment must take the following points into consideration:</p>
<p class="calibre71">     •     <em class="italic">Data distribution</em>. In a DDBMS, query translation is more complicated because the DDBMS must decide which fragment to access. (Distribution transparency was explained earlier in this chapter.) In this case, a TP executing a query must choose what fragments to access, create multiple data requests to the chosen remote DPs, combine the DP responses, and present the data to the application.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Data replication</em>. In addition, the data may also be replicated at several different sites. The data replication makes the access problem even more complex because the database must ensure that all copies of the data are consistent. Therefore, an important characteristic of query optimization in distributed database systems is that it must provide replica transparency. <a id="filepos2107891"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2853307"><strong class="calibre14">Replica transparency</strong></a> refers to the DDBMS’s ability to hide multiple copies of data from the user. This ability is particularly important with data update operations. If a read-only request is being processed, it can be satisfied by accessing any available remote DP. However, processing a write request also involves “synchronizing” all existing fragments to maintain data consistency. The two-phase commit protocol you learned about in <a href="#filepos2097730">Section 12.9.3</a> ensures that the transaction will complete successfully. However, if data are replicated at other sites, the DDBMSs must also ensure the consistency of all the fragments—that is, all fragments should be mutually consistent. To accomplish this, a DP captures all changes and pushes them to each remote replica. This introduces delays in the system and basically means that not all data changes are immediately seen by all replicas. (The implications of this issue are explained in <a href="#filepos2132847">Section 12.12</a>, The CAP Theorem.)</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Network and node availability</em>. The response time associated with remote sites cannot be easily predetermined because some nodes finish their part of the query in less time than others and network path performance varies because of bandwidth and traffic loads. Hence, to achieve performance transparency, the DDBMS should consider issues such as <a id="filepos2109395"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2827667"><strong class="calibre14">network latency</strong></a>, the delay imposed by the amount of time required for a data packet to make a round trip from point A to point B; or <a id="filepos2109579"></a><strong class="calibre14">network partitioning</strong>, the delay imposed when nodes become suddenly unavailable due to a network failure.</p><div class="calibre58"> </div>
<p class="calibre9">Carefully planning how to partition a database and where to locate the database fragments can help ensure the performance and consistency of a distributed database. The following section discusses issues for distributed database design.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2110171"></a>12.11 D<span><span class="calibre68">ISTRIBUTED</span></span> D<span><span class="calibre68">ATABASE</span></span> D<span><span class="calibre68">ESIGN</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Whether the database is centralized or distributed, the design principles and concepts described in <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_015.html#filepos411532">Chapters 3</a>, <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_016.html#filepos562149">4</a>, and <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_018.html#filepos861217">6</a> are still applicable. However, the design of a distributed database introduces three new issues:</p>
<p class="calibre71">     •     How to partition the database into fragments</p><div class="calibre58"> </div>
<p class="calibre71">     •     Which fragments to replicate</p><div class="calibre58"> </div>
<p class="calibre71">     •     Where to locate those fragments and replicas</p><div class="calibre58"> </div>
<p class="calibre9">Data fragmentation and data replication deal with the first two issues, and data allocation deals with the third issue. Ideally, data in a distributed database should be evenly distributed to maximize performance, increase availability (reduce bottlenecks), and provide location awareness, which is an ever-increasing requirement for mobile applications.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos2111550"></a> 12.11.1 D<span><span class="calibre5">ATA</span></span> F<span><span class="calibre5">RAGMENTATION</span></span></span></p>
<hr class="calibre10"/><p class="calibre9"><a id="filepos2111737"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2758380"><strong class="calibre14">Data fragmentation</strong></a> allows you to break a single object into two or more segments, or fragments. The object might be a user’s database, a system database, or a table. Each fragment can be stored at any site over a computer network. Information about data fragmentation is stored in the distributed data catalog (DDC), from which it is accessed by the TP to process user requests.</p>
<p class="calibre9">Data fragmentation strategies, as discussed here, are based at the table level and consist of dividing a table into logical fragments. You will explore three types of data fragmentation strategies: horizontal, vertical, and mixed. (Keep in mind that a fragmented table can always be re-created from its fragmented parts by a combination of unions and joins.)</p>
<p class="calibre71">     •     <a id="filepos2112675"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2802221"><strong class="calibre14">Horizontal fragmentation</strong></a> refers to the division of a relation into subsets (fragments) of tuples (rows). Each fragment is stored at a different node, and each fragment has unique rows. However, the unique rows all have the same attributes (columns). In short, each fragment represents the equivalent of a SELECT statement, with the WHERE clause on a single attribute.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <a id="filepos2113174"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2887435"><strong class="calibre14">Vertical fragmentation</strong></a> refers to the division of a relation into attribute (column) subsets. Each subset (fragment) is stored at a different node, and each fragment has unique columns—with the exception of the key column, which is common to all fragments. This is the equivalent of the PROJECT statement in SQL.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <a id="filepos2113617"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2823359"><strong class="calibre14">Mixed fragmentation</strong></a> refers to a combination of horizontal and vertical strategies. In other words, a table may be divided into several horizontal subsets (rows), each one having a subset of the attributes (columns).</p><div class="calibre58"> </div>
<p class="calibre9">To illustrate the fragmentation strategies, use the CUSTOMER table for the XYZ Company, as depicted in <a href="#filepos2114351">Figure 12.15</a>. The table contains the attributes CUS_NUM, CUS_NAME, CUS_ADDRESS, CUS_STATE, CUS_LIMIT, CUS_BAL, CUS_RATING, and CUS_DUE.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2114351"></a><strong class="calibre14">FIGURE 12.15 A sample CUSTOMER table</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00480.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><hr class="calibre10"/><p class="calibre63"><span class="calibre35"><img alt="img" src="images/00023.jpg" class="calibre7"/> O<span><span class="calibre68">NLINE</span></span> C<span><span class="calibre68">ONTENT</span></span></span></p>
<p class="calibre9">The databases used to illustrate the material in this chapter are available at <a href="http://www.cengagebrain.com"><em class="italic">www.cengagebrain.com</em></a>.</p>
<hr class="calibre10"/><p class="calibre83"><span class="calibre5"><strong class="calibre14">Horizontal Fragmentation</strong></span></p>
<p class="calibre53">In this case, a table is divided into multiple subsets of rows. There are various ways to partition a table horizontally:</p>
<p class="calibre71">     •     <em class="italic">Round-robin partitioning</em>. Rows are assigned to a given fragment in a round-robin fashion (F1, F2, F3, ..., F<em class="italic">n</em>) to ensure an even distribution of rows among all fragments. However, this is not a good strategy if you require “location awareness”—the ability to determine which DP node will process a query based on the geospatial location of the requester. For example, you would want all queries from Florida customers to be resolved from a fragment that stores only Florida customers. Of course, you also would like this fragment to be located in a node close to Florida.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Range partitioning based on a partition key</em>. A <a id="filepos2116208"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2837760"><strong class="calibre14">partition key</strong></a> is one or more attributes in a table that determine the fragment in which a row will be stored. For example, if you want to provide location awareness, a good partition key would be the customer state field. This is the most common and useful data partitioning strategy.</p><div class="calibre58"> </div>
<p class="calibre9">Take a closer look at how to use a partition key to partition a table. Suppose that the XYZ Company’s corporate management requires information about its customers in all three states, but company locations in each state (TN, FL, and GA) require data regarding local customers only. Based on such requirements, you decide to distribute the data by state. Therefore, you define the horizontal fragments to conform to the structure shown in <a href="#filepos2114351">Table 12.15</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><strong class="calibre14">TABLE 12.5 Horizontal Fragmentation of the CUSTOMER Table by State</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00481.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre9">The partition key will be the CUS_STATE field. Each horizontal fragment may have a different number of rows, but each fragment <em class="italic">must</em> have the same attributes. The resulting fragments yield the three tables depicted in <a href="#filepos2117894">Figure 12.16</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2117894"></a><strong class="calibre14">FIGURE 12.16 Table fragments in three locations</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00482.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre83"><span class="calibre5"><strong class="calibre14">Vertical Fragmentation</strong></span></p>
<p class="calibre53">You may also divide the CUSTOMER relation into vertical fragments that are composed of a collection of attributes. For example, suppose that the company is divided into two departments: the service department and the collections department. Each department is located in a separate building, and each has an interest in only a few of the CUSTOMER table’s attributes. In this case, the fragments are defined as shown in <a href="#filepos2118994">Table 12.6</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2118994"></a><strong class="calibre14">TABlE 12.6 Vertical Fragmentation of the CUSTOMER Table</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00483.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre9">Each vertical fragment must have the same number of rows, but the inclusion of the different attributes depends on the key column. The vertical fragmentation results are displayed in <a href="#filepos2119706">Figure 12.17</a>. Note that the key attribute (CUS_NUM) is common to both fragments CUST_V1 and CUST_V2.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2119706"></a><strong class="calibre14">FIGURE 12.17 Vertically fragmented table contents</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00484.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre83"><span class="calibre5"><strong class="calibre14">Mixed Fragmentation</strong></span></p>
<p class="calibre53">The XYZ Company’s structure requires that the CUSTOMER data be fragmented horizontally to accommodate the various company locations; within the locations, the data must be fragmented vertically to accommodate the two departments (service and collection). In short, the CUSTOMER table requires mixed fragmentation.</p>
<p class="calibre9">Mixed fragmentation requires a two-step procedure. First, horizontal fragmentation is introduced for each site based on the location within a state (CUS_STATE). The horizontal fragmentation yields the subsets of customer tuples (horizontal fragments) that are located at each site. Because the departments are located in different buildings, vertical fragmentation is used within each horizontal fragment to divide the attributes, thus meeting each department’s information needs at each subsite. Mixed fragmentation yields the results displayed in <a href="#filepos2121318">Table 12.7</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2121318"></a><strong class="calibre14">TABLE 12.7 Mixed Fragmentation of the CUSTOMER Table</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00485.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre9">Each fragment displayed in <a href="#filepos2121318">Table 12.7</a> contains customer data by state and, within each state, by department location to fit each department’s data requirements. The tables corresponding to the fragments listed in <a href="#filepos2121318">Table 12.7</a> are shown in <a href="#filepos2122048">Figure 12.18</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2122048"></a><strong class="calibre14">FIGURE 12.18 Table contents after the mixed fragmentation process</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00486.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><a id="filepos2122464"></a>12.11.2 D<span><span class="calibre5">ATA</span></span> R<span><span class="calibre5">EPLICATION</span></span></span></p>
<hr class="calibre10"/><p class="calibre9"><a id="filepos2122648"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2762510"><strong class="calibre14">Data replication</strong></a> refers to the storage of data copies at multiple sites served by a computer network. Fragment copies can be stored at several sites to serve specific information requirements. Because the existence of fragment copies can enhance data availability and response time, data copies can help to reduce communication and total query costs.</p>
<p class="calibre9">Suppose database A is divided into two fragments, A1 and A2. Within a replicated distributed database, the scenario depicted in <a href="#filepos2123522">Figure 12.19</a> is possible: fragment A1 is stored at sites S1 and S2, while fragment A2 is stored at sites S2 and S3.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2123522"></a><strong class="calibre14">FIGURE 12.19 Data replication</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00487.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Replicated data are subject to the <a id="filepos2123937"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2826287"><strong class="calibre14">mutual consistency rule</strong></a>, which requires that all copies of data fragments be identical. Therefore, to maintain data consistency among the replicas, the DDBMS must ensure that a database update is performed at all sites where replicas exist.</p>
<p class="calibre9">There are basically two styles of replication:</p>
<p class="calibre71">     •     <em class="italic">Push replication</em>. After a data update, the originating DP node sends the changes to the replica nodes to ensure that data are immediately updated. This type of replication focuses on maintaining data consistency. However, it decreases data availability due to the latency involved in ensuring data consistency at all nodes.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Pull replication</em>. After a data update, the originating DP node sends “messages” to the replica nodes to notify them of the update. The replica nodes decide when to apply the updates to their local fragment. In this type of replication, data updates propagate more slowly to the replicas. The focus is on maintaining data availability. However, this style of replication allows for temporary data inconsistencies.</p><div class="calibre58"> </div>
<p class="calibre9">Although replication has some benefits, such as improved data availability, better load distribution, improved data failure tolerance, and reduced query costs, it also imposes additional DDBMS processing overhead because each data copy must be maintained by the system. Furthermore, because the data are replicated at another site, there are associated storage costs and increased transaction times (as data must be updated at several sites concurrently to comply with the mutual consistency rule). To illustrate the replica overhead imposed on a DDBMS, consider the processes that the DDBMS must perform to use the database:</p>
<p class="calibre71">     •     If the database is fragmented, the DDBMS must decompose a query into subqueries to access the appropriate fragments.</p><div class="calibre58"> </div>
<p class="calibre71">     •     If the database is replicated, the DDBMS must decide which copy to access. A READ operation selects the <em class="italic">nearest copy</em> to satisfy the transaction. A WRITE operation requires that <em class="italic">all copies</em> be selected and updated to satisfy the mutual consistency rule.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The TP sends a data request to each selected DP for execution.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The DP receives and executes each request and sends the data back to the TP.</p><div class="calibre58"> </div>
<p class="calibre71">     •     The TP assembles the DP responses.</p><div class="calibre58"> </div>
<p class="calibre9">The problem becomes more complex when you consider additional factors such as network topology and communication throughputs.</p>
<p class="calibre9">Three replication scenarios exist: a database can be fully replicated, partially replicated, or unreplicated.</p>
<p class="calibre71">     •     A <a id="filepos2127373"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2796894"><strong class="calibre14">fully replicated database</strong></a> stores multiple copies of each database fragment at multiple sites. In this case, all database fragments are replicated. A fully replicated database can be impractical due to the amount of overhead it imposes on the system.</p><div class="calibre58"> </div>
<p class="calibre71">     •     A <a id="filepos2127756"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2837110"><strong class="calibre14">partially replicated database</strong></a> stores multiple copies of some database fragments at multiple sites. Most DDBMSs are able to handle the partially replicated database well.</p><div class="calibre58"> </div>
<p class="calibre71">     •     An <a id="filepos2128060"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2885947"><strong class="calibre14">unreplicated database</strong></a> stores each database fragment at a single site. Therefore, there are no duplicate database fragments.</p><div class="calibre58"> </div>
<p class="calibre9">Several factors influence the decision to use data replication:</p>
<p class="calibre71">     •     <em class="italic">Database size</em>. The amount of data replicated will have an impact on the storage requirements and the data transmission costs. Replicating large amounts of data requires a window of time and higher network bandwidth that could affect other applications.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Usage frequency</em>. The frequency of data usage determines how frequently the data need to be updated. Frequently used data should be updated more often, for example, than large data sets that are used only every quarter.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Costs</em>. Costs include those for performance, software overhead, and management associated with synchronizing transactions and their components versus fault-tolerance benefits that are associated with replicated data.</p><div class="calibre58"> </div>
<p class="calibre9">When the usage frequency of remotely located data is high and the database is large, data replication can reduce the cost of data requests. Data replication information is stored in the DDC, whose contents are used by the TP to decide which copy of a database fragment to access. The data replication makes it possible to restore lost data.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos2129802"></a>12.11.3 D<span><span class="calibre5">ATA</span></span> A<span><span class="calibre5">LLOCATION</span></span></span></p>
<hr class="calibre10"/><p class="calibre9"><a id="filepos2129985"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2754620"><strong class="calibre14">Data allocation</strong></a> describes the process of deciding where to locate data. Data allocation strategies are as follows:</p>
<p class="calibre71">     •     With <a id="filepos2130236"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2740002"><strong class="calibre14">centralized data allocation</strong></a>, the entire database is stored at one site.</p><div class="calibre58"> </div>
<p class="calibre71">     •     With <a id="filepos2130444"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2838008"><strong class="calibre14">partitioned data allocation</strong></a>, the database is divided into two or more disjointed parts (fragments) and stored at two or more sites.</p><div class="calibre58"> </div>
<p class="calibre71">     •     With <a id="filepos2130712"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2853527"><strong class="calibre14">replicated data allocation</strong></a>, copies of one or more database fragments are stored at several sites.</p><div class="calibre58"> </div>
<p class="calibre9">Data distribution over a computer network is achieved through data partitioning, through data replication, or through a combination of both. Data allocation is closely related to the way a database is divided or fragmented. Most data allocation studies focus on one issue: which data to locate where.</p>
<p class="calibre9">Data allocation algorithms consider a variety of factors, including:</p>
<p class="calibre71">     •     Performance and data availability goals</p><div class="calibre58"> </div>
<p class="calibre71">     •     Size, number of rows, and number of relations that an entity maintains with other entities</p><div class="calibre58"> </div>
<p class="calibre71">     •     Types of transactions to be applied to the database and the attributes accessed by each of those transactions</p><div class="calibre58"> </div>
<p class="calibre71">     •     Disconnected operation for mobile users. In some cases, the design might consider the use of loosely disconnected fragments for mobile users, particularly for read-only data that do not require frequent updates and for which the replica update windows may be longer. (A replica update window is the amount of time available to perform a data-processing task that cannot be executed concurrently with other tasks.)</p><div class="calibre58"> </div>
<p class="calibre9">Most algorithms include data such as network topology, network bandwidth and throughput, data size, and location. No optimal or universally accepted algorithm exists yet, and each database vendor implements its own version to showcase the strengths of its respective products.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2132847"></a>12.12 T<span><span class="calibre68">HE</span></span> C<span><span class="calibre68">AP</span></span> T<span><span class="calibre68">HEOREM</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">In a 2000 symposium on distributed computing, Dr. Eric Brewer stated in his presentation that “in any highly distributed data system there are three commonly desirable properties: consistency, availability, and partition tolerance. However, it is impossible for a system to provide all three properties at the same time.”<sup class="calibre56"><a href="#filepos2171433">2</a></sup> The initials <em class="italic">CAP</em> stand for the three desirable properties. Consider these three properties in more detail:</p>
<p class="calibre71">     •     <em class="italic">Consistency</em>. In a distributed database, consistency takes a bigger role. All nodes should see the same data at the same time, which means that the replicas should be immediately updated. However, this involves dealing with latency and network partitioning delays, as you learned in <a href="#filepos2103382">Section 12.10</a>.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Availability</em>. Simply speaking, a request is always fulfilled by the system. No received request is ever lost. If you are buying tickets online, you do not want the system to stop in the middle of the operation. This is a paramount requirement of all Web-centric organizations.</p><div class="calibre58"> </div>
<p class="calibre71">     •     <em class="italic">Partition tolerance</em>. The system continues to operate even in the event of a node failure. This is the equivalent of failure transparency in distributed databases (see <a href="#filepos2072492">Section 12.7</a>). The system will fail only if all nodes fail.</p><div class="calibre58"> </div>
<p class="calibre9">Although the CAP theorem focuses on highly distributed Web-based systems, its implications are widespread for all distributed systems, including databases.</p>
<p class="calibre9">In <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_028.html#filepos1760802">Chapter 10</a>, you learned that there are four database transaction properties: atomicity, consistency, isolation, and durability. The ACID properties ensure that all successful transactions result in a consistent database state—one in which all data operations always return the same results. For centralized and small distributed databases, latency is not an issue. As the business grows and the need for availability increases, database latency becomes a bigger problem. It is more difficult for a highly distributed database to ensure ACID transactions without paying a high price in network latency or data contention (delays imposed by concurrent data access).</p>
<p class="calibre9">For example, imagine that you are using Amazon to buy tickets for the Manchester United–Barcelona soccer game in Washington, D.C. You may spend a few minutes browsing through the available tickets and checking the stadium Website to see which seats have the best view. At the same time, other users from all over the world may be doing exactly the same thing. By the time you click the checkout button, the tickets you selected may already be purchased by someone else! In this case, you will start again and select other tickets until you get the ones you want. The Website is designed to work this way on purpose because Amazon prefers the small probability of having a few customers restart their transactions than to lock the database to ensure consistency and have thousands of customers waiting for their Web pages to refresh. If you have noticed the small countdown clock when using Ticketmaster to buy concert tickets, you have seen the same principle at work.</p>
<p class="calibre9">As this example shows, when dealing with highly distributed systems, some companies tend to forfeit the consistency and isolation components of the ACID properties to achieve higher availability. This trade-off between consistency and availability has generated a new type of distributed data systems in which data are <a id="filepos2137076"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2733919"><strong class="calibre14">basically available, soft state, eventually consistent (BASE)</strong></a>. BASE refers to a data consistency model in which data changes are not immediate but propagate slowly through the system until all replicas are eventually consistent. For example, NoSQL databases provide a highly distributed database with eventual consistency (see <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_012.html#filepos268583">Chapter 2</a>). In practice, the emergence of NoSQL distributed databases now provides a spectrum of consistency that ranges from the highly consistent (ACID) to the eventually consistent (BASE), as shown in <a href="#filepos2137854">Table 12.8</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2137854"></a><strong class="calibre14">TABLE 12.8 Distributed Database Spectrum</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00488.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos2138196"></a>12.13 C. J. D<span><span class="calibre68">ATE’S</span></span> 12 C<span><span class="calibre68">OMMANDMENTS FOR</span></span> D<span><span class="calibre68">ISTRIBUTED</span></span> D<span><span class="calibre68">ATABASES</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">The notion of distributed databases has been around for at least 20 years. With the rise of relational databases, most vendors implemented their own versions of distributed databases, generally highlighting their respective product’s strengths. To make comparisons easier, C. J. Date formulated 12 “commandments” or basic principles of distributed databases.<sup class="calibre56"><a href="#filepos2171987">3</a></sup> Although no current DDBMS conforms to all of them, they constitute a useful target. The 12 rules are shown in <a href="#filepos2139163">Table 12.9</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2139163"></a><strong class="calibre14">TABLE 12.9 Date’s 12 Commandments for Distributed Databases</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00489.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre78"><span class="calibre8"><span class="calibre14"><a id="filepos2139538"></a>SUMMARY</span></span></p></blockquote>
<hr class="calibre10"/><p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   A distributed database stores logically related data in two or more physically independent sites connected via a computer network. The database is divided into fragments, which can be a horizontal set of rows or a vertical set of attributes. Each fragment can be allocated to a different network node.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Distributed processing is the division of logical database processing among two or more network nodes. Distributed databases require distributed processing. A distributed database management system (DDBMS) governs the processing and storage of logically related data through interconnected computer systems.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   The main components of a DDBMS are the transaction processor (TP) and the data processor (DP). The transaction processor component is the resident software on each computer node that requests data. The data processor component is the resident software on each computer that stores and retrieves data.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Current database systems can be classified by the extent to which they support processing and data distribution. Three major categories are used to classify distributed database systems: single-site processing, single-site data (SPSD); multiple-site processing, single-site data (MPSD); and multiple-site processing, multiple-site data (MPMD).</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   A homogeneous distributed database system integrates only one particular type of DBMS over a computer network. A heterogeneous distributed database system integrates several different types of DBMSs over a computer network.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   DDBMS characteristics are best described as a set of transparencies: distribution, transaction, performance, failure, and heterogeneity. All transparencies share the common objective of making the distributed database behave as though it were a centralized database system; that is, the end user sees the data as part of a single, logical centralized database and is unaware of the system’s complexities.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   A transaction is formed by one or more database requests. An undistributed transaction updates or requests data from a single site. A distributed transaction can update or request data from multiple sites.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Distributed concurrency control is required in a network of distributed databases. A two-phase COMMIT protocol is used to ensure that all parts of a transaction are completed.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   A distributed DBMS evaluates every data request to find the optimum access path in a distributed database. The DDBMS must optimize the query to reduce associated access costs, communication costs, and CPU costs.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   The design of a distributed database must consider the fragmentation and replication of data. The designer must also decide how to allocate each fragment or replica to obtain better overall response time and to ensure data availability to the end user. Ideally, a distributed database should evenly distribute data to maximize performance, availability, and location awareness.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   A database can be replicated over several different sites on a computer network. The replication of the database fragments has the objective of improving data availability, thus decreasing access time. A database can be partially, fully, or not replicated. Data allocation strategies are designed to determine the location of the database fragments or replicas.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   The CAP theorem states that a highly distributed data system has some desirable properties of consistency, availability, and partition tolerance. However, a system can only provide two of these properties at a time.</span></p><div class="calibre3"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre80"><span class="calibre8"><span class="calibre14"><a id="filepos2144703"></a>KEY TERMS</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2056890">application processor (AP)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2137076">basically available, soft state, eventually consistent (BASE)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2130236">centralized data allocation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2067364">client/server architecture</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2100428">coordinator</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2129985">data allocation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2046476">database fragments</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2111737">data fragmentation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2057356">data manager (DM)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2057136">data processor (DP)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2122648">data replication</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2046036">distributed database</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2028237">distributed database management system (DDBMS)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2084549">distributed data catalog (DDC)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2084459">distributed data dictionary (DDD)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2084766">distributed global schema</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2044592">distributed processing</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2092596">distributed request</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2090158">distributed transaction</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2073154">distribution transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2099130">DO-UNDO-REDO protocol</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2074451">failure transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2076790">fragmentation transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2069713">fully heterogeneous DDBMS</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2127373">fully replicated database</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2075626">heterogeneity transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2069417">heterogeneous DDBMS</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2069195">homogeneous DDBMS</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2112675">horizontal fragmentation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2077457">local mapping transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2077160">location transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2113617">mixed fragmentation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2068763">multiple-site processing, multiple-site data (MPMD)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2064319">multiple-site processing, single-site data (MPSD)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2123937">mutual consistency rule</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2109395">network latency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2109579">network partitioning</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2127756">partially replicated database</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2130444">partitioned data allocation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2116208">partition key</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2074942">performance transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2087717">remote request</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2088562">remote transaction</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2107891">replica transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2130712">replicated data allocation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2062347">single-site processing, single-site data (SPSD)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2100507">subordinates</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2056975">transaction manager (TM)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2056599">transaction processor (TP)</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2074084">transaction transparency</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2098371">two-phase commit protocol</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2079581">unique fragment</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2128060">unreplicated database</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2113174">vertical fragmentation</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos2100105">write-ahead protocol</a></span></p></blockquote>
<hr class="calibre10"/><p class="calibre63"><span class="calibre35"><img alt="img" src="images/00023.jpg" class="calibre7"/> O<span><span class="calibre68">NLINE</span></span> C<span><span class="calibre68">ONTENT</span></span></span></p>
<p class="calibre9">Flashcards and crossword puzzles for key term practice are available at <a href="http://www.cengagebrain.com"><em class="italic">www.cengagebrain.com</em></a>.</p>
<hr class="calibre10"/><p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre6"><span class="calibre8"><span class="calibre14"><a id="filepos2154294"></a>REVIEW QUESTIONS</span></span></p>
<hr class="calibre10"/><p class="calibre79"><span class="calibre5">  1.  Describe the evolution from centralized DBMSs to distributed DBMSs.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  List and discuss some of the factors that influenced the evolution of the DDBMS.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  3.  What are the advantages of the DDBMS?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  4.  What are the disadvantages of the DDBMS?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  5.  Explain the difference between a distributed database and distributed processing.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  6.  What is a fully distributed database management system?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  7.  What are the components of a DDBMS?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  8.  List and explain the transparency features of a DDBMS.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  9.  Define and explain the different types of distribution transparency.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">10.  Describe the different types of database requests and transactions.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">11.  Explain the need for the two-phase commit protocol. Then describe the two phases.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">12.  What is the objective of query optimization functions?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">13.  To which transparency feature are the query optimization functions related?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">14.  What issues should be considered when resolving data requests in a distributed data environment?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">15.  Describe the three data fragmentation strategies. Give some examples of each.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">16.  What is data replication, and what are the three replication strategies?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">17.  What are the two basic styles of data replication?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">18.  What trade-offs are involved in building highly distributed data environments?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">19.  How does a BASE system differ from a traditional distributed database system?</span></p><div class="calibre3"> </div>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre6"><span class="calibre8"><span class="calibre14"><a id="filepos2157576"></a>PROBLEMS</span></span></p>
<hr class="calibre10"/><p class="calibre9">The first problem is based on the DDBMS scenario in <a href="#filepos2157903">Figure P12.1</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos2157903"></a><strong class="calibre14">FIGURE P12.1 The DDBMS scenario for <a href="#filepos2158353">Problem 1</a></strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00490.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2158353"></a>1.    Specify the minimum types of operations the database must support to perform the following operations. These operations include remote requests, remote transactions, distributed transactions, and distributed requests.</span></p></blockquote><div class="calibre3"> </div>
<div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5"><strong class="calibre14">At site C</strong></span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">a.   SELECT</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">*</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">CUSTOMER;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">b.   SELECT</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">*</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">INVOICE</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">INV_TOT &gt; 1000;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">c.   SELECT</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">*</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">PRODUCT</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">PROD_ QOH &lt; 10;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">d.   BEGIN WORK;</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63"></p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">UPDATE</p></blockquote></td><td class="calibre62"><p class="calibre63">CUSTOMER</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">SET</p></blockquote></td><td class="calibre62"><p class="calibre63">CUS_BAL = CUS_BAL + 100</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">CUS_NUM = ‘10936’;</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">INSERT</p></blockquote></td><td class="calibre62"><p class="calibre63">INTO INVOICE(INV_NUM, CUS_NUM, INV_DATE, INV_TOTAL)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">VALUES (‘986391’, ‘10936’, ‘15-FEB-2012’, 100);</p></blockquote></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">INSERT</p></blockquote></td><td class="calibre62"><p class="calibre63">INTO LINE(INV_NUM, PROD_NUM, LINE_PRICE)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">VALUES (‘986391’, ‘1023’, 100);</p></blockquote></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">UPDATE</p></blockquote></td><td class="calibre62"><p class="calibre63">PRODUCT</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">SET</p></blockquote></td><td class="calibre62"><p class="calibre63">PROD_QOH = PROD_ QOH —1</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">PROD_NUM = ‘1023’;</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">COMMIT WORK;</p></blockquote></td><td class="calibre62"><p class="calibre63"></p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">e.   BEGIN WORK;</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63"></p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">INSERT</p></blockquote></td><td class="calibre62"><p class="calibre63">INTO CUSTOMER(CUS_NUM, CUS_NAME, CUS_ADDRESS, CUS_BAL)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><p class="calibre63">VALUES (‘34210’, ‘Victor Ephanor’, ‘123 Main St.’, 0.00);</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">INSERT</p></blockquote></td><td class="calibre62"><p class="calibre63">INTO INVOICE(INV_NUM, CUS_NUM, INV_DATE, INV_TOTAL)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"></p></td><td class="calibre62"><p class="calibre63">VALUES (‘986434’, ‘34210’, ‘10-AUG-2011’, 2.00);</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">COMMIT WORK;</p></blockquote></td><td class="calibre62"><p class="calibre63"></p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5"><strong class="calibre14">At site A</strong></span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">f.   SELECT                </span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">CUS_NUM, CUS_NAME, INV_TOTAL</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">CUSTOMER, INVOICE</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">CUSTOMER.CUS_NUM = INVOICE.CUS_NUM;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">g.   SELECT</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">*</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">INVOICE</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">INV_TOTAL &gt; 1000;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">h.   SELECT</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">*</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">PRODUCT</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">PROD_QOH &lt; 10;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5"><strong class="calibre14">At site B</strong></span></p><div class="calibre3"> </div></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">i.   SELECT                </span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">*</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">CUSTOMER;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">j.   SELECT</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">CUS_NAME, INV_TOTAL</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">CUSTOMER, INVOICE</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">INV_TOTAL &gt; 1000 AND CUSTOMER.CUS_NUM = INVOICE.CUS_NUM;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre95"><span class="calibre5">k.   SELECT</span></p><div class="calibre3"> </div></td><td class="calibre62"><p class="calibre63">*</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">FROM</p></blockquote></td><td class="calibre62"><p class="calibre63">PRODUCT</p></td></tr><tr class="calibre61"><td class="calibre62"><blockquote class="calibre38"><p class="calibre63">WHERE</p></blockquote></td><td class="calibre62"><p class="calibre63">PROD_QOH &lt; 10;</p></td></tr></div></table><div class="calibre64"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2167284"></a>2.    The following data structure and constraints exist for a magazine publishing company:</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a id="filepos2167510"></a>a.   The company publishes one regional magazine in each of four states: Florida (FL), South Carolina (SC), Georgia (GA), and Tennessee (TN).</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>b.   The company has 300,000 customers (subscribers) distributed throughout the four states listed in <a href="#filepos2167510">Problem 2a</a>.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>c.   On the first day of each month, an annual subscription INVOICE is printed and sent to each customer whose subscription is due for renewal. The INVOICE entity contains a REGION attribute to indicate the customer’s state of residence (FL, SC, GA, TN):<br class="calibre15"/>CUSTOMER (CUS_NUM, CUS_NAME, CUS_ADDRESS, CUS_CITY, CUS_ZIP, CUS_SUBSDATE) <br class="calibre15"/>INVOICE (INV_NUM, INV_REGION, CUS_NUM, INV_DATE, INV_TOTAL) <br class="calibre15"/>The company is aware of the problems associated with centralized management and has decided to decentralize management of the subscriptions into the company’s four regional subsidiaries. Each subscription site will handle its own customer and invoice data. The management at company headquarters, however, will have access to customer and invoice data to generate annual reports and to issue ad hoc queries such as:</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre74">•     Listing all current customers by region</p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre74">•     Listing all new customers by region</p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre74">•     Reporting all invoices by customer and by region Given those requirements, how must you partition the database?</p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>3.    Given the scenario and requirements in <a href="#filepos2167284">Problem 2</a>, answer the following questions:</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>a.   What recommendations will you make regarding the type and characteristics of the required database system?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>b.   What type of data fragmentation is needed for each table?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>c.   What criteria must be used to partition each database?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>d.   Design the database fragments. Show an example with node names, location, fragment names, attribute names, and demonstration data.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>e.   What type of distributed database operations must be supported at each remote site?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5"><a></a>f.   What type of distributed database operations must be supported at the headquarters site?</span></p></blockquote><div class="calibre3"> </div>
<div class="calibre67"> </div><hr class="calibre10"/><blockquote class="calibre38"><p class="calibre63"><span class="calibre8"><a id="filepos2171134"></a>1 The details of distributed requests and transactions were originally described by David McGoveran and Colin White, “Clarifying Client/Server,” <em class="italic">DBMS</em> 3(12), November 1990.</span></p></blockquote>
<blockquote class="calibre38"><p class="calibre63"><span class="calibre8"><a id="filepos2171433"></a>2 “Towards Robust Distributed Systems,” Eric A. Brewer, University of California at Berkeley and Inktomi Corporation, presentation at the Principles of Distributed Computing, ACM Symposium, July 2000. This theorem was later proven by Seth Gilbert and Nancy Lynch of MIT in their paper “Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services,” <em class="italic">ACM SIGACT News</em>, vol. 33, Issue 2, 2002.</span></p></blockquote>
<blockquote class="calibre38"><p class="calibre63"><span class="calibre8"><a id="filepos2171987"></a>3 Date, C. J., “Twelve Rules for a Distributed Database,” <em class="italic">Computerworld</em>, June 8, 1987, 2(23).</span></p></blockquote>  <div class="mbppagebreak" id="calibre_pb_29"></div></body></html>
