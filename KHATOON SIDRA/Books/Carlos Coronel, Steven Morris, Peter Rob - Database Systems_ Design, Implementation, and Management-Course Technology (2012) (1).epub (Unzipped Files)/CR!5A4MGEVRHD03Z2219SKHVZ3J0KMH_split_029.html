<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Database Systems: Design, Implementation, and Management, Tenth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1888337"></a>11 <span><span class="calibre68">D<span><span class="calibre5">ATABASE</span></span> P<span><span class="calibre5">ERFORMANCE</span></span> T<span><span class="calibre5">UNING AND</span></span> Q<span><span class="calibre5">UERY</span></span> O<span><span class="calibre5">PTIMIZATION</span></span></span></span></span></p>
<hr class="calibre10"/><p class="calibre9">In this chapter, you will learn:</p>
<p class="calibre45">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   Basic database performance-tuning concepts</p><div class="calibre3"> </div>
<p class="calibre45"><span class="calibre5">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   How a DBMS processes SQL queries</span></p><div class="calibre3"> </div>
<p class="calibre45"><span class="calibre5">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   About the importance of indexes in query processing</span></p><div class="calibre3"> </div>
<p class="calibre45"><span class="calibre5">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   About the types of decisions the query optimizer has to make</span></p><div class="calibre3"> </div>
<p class="calibre45"><span class="calibre5">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   Some common practices used to write efficient SQL code</span></p><div class="calibre3"> </div>
<p class="calibre45"><span class="calibre5">     <img alt="img" src="images/00016.jpg" class="calibre7"/>   How to formulate queries and tune the DBMS for optimal performance</span></p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre26"><span><span class="calibre27">P</span></span>review</span></p>
<hr class="calibre10"/><p class="calibre9">Database performance tuning is a critical topic, yet it usually receives minimal coverage in the database curriculum. Most databases used in classrooms have only a few records per table. As a result, the focus is often on making SQL queries perform an intended task, without considering the efficiency of the query process. In fact, even the most efficient query environment yields no visible performance improvements over the least efficient query environment when only 20 or 30 table rows (records) are queried. Unfortunately, that lack of attention to query efficiency can yield unacceptably slow results in the real world when queries are executed over tens of millions of records. In this chapter, you will learn what it takes to create a more efficient query environment.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63">N<span><span class="calibre8">OTE</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre53">Because this book focuses on databases, this chapter covers only the factors that directly affect <em class="italic">database</em> performance. Also, because performance-tuning techniques can be DBMS-specific, the material in this chapter might not be applicable under all circumstances, nor will it necessarily pertain to all DBMS types. This chapter is designed to build a foundation for the general understanding of database performance-tuning issues and to help you choose appropriate performance-tuning strategies. (For the most current information about tuning your database, consult the vendor’s documentation.)</p></blockquote>
<hr class="calibre10"/><p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1891895"></a>11.1 D<span><span class="calibre68">ATABASE</span></span> P<span><span class="calibre68">ERFORMANCE</span></span>-T<span><span class="calibre68">UNING</span></span> C<span><span class="calibre68">ONCEPTS</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">One of the main functions of a database system is to provide timely answers to end users. End users interact with the DBMS through the use of queries to generate information, using the following sequence:</p>
<p class="calibre79"><span class="calibre5">  1.  The end-user (client-end) application generates a query.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  The query is sent to the DBMS (server end).</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  3.  The DBMS (server end) executes the query.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  4.  The DBMS sends the resulting data set to the end-user (client-end) application.</span></p>
<p class="calibre9">End users expect their queries to return results as quickly as possible. How do you know that the performance of a database is good? Good database performance is hard to evaluate. How do you know if a 1.06-second query response time is good enough? It is easier to identify bad database performance than good database performance—all it takes is end-user complaints about slow query results. Unfortunately, the same query might perform well one day and not so well two months later. Regardless of end-user perceptions, <em class="italic">the goal of database performance is to execute queries as fast as possible</em>. Therefore, database performance must be closely monitored and regularly tuned. <a id="filepos1893734"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2767548">Database performance tuning</a></strong> refers to a set of activities and procedures designed to reduce the response time of the database system—that is, to ensure that an end-user query is processed by the DBMS in the minimum amount of time.</p>
<p class="calibre9">The time required by a query to return a result set depends on many factors, which tend to be wide-ranging and to vary among environments and among vendors. The performance of a typical DBMS is constrained by three main factors: CPU processing power, available primary memory (RAM), and input/output (hard disk and network) throughput. <a href="#filepos1894692">Table 11.1</a> lists some system components and summarizes general guidelines for achieving better query performance.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos1894692"></a><strong class="calibre14">TABLE 11.1 General Guidelines for Better System Performance</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00448.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<hr class="calibre10"/><p class="calibre9">Naturally, the system will perform best when its hardware and software resources are optimized. However, in the real world, unlimited resources are not the norm; internal and external constraints always exist. Therefore, the system components should be optimized to obtain the best throughput possible with existing (and often limited) resources, which is why database performance tuning is important.</p>
<p class="calibre9">Fine-tuning the performance of a system requires a holistic approach. That is, <em class="italic">all</em> factors must be checked to ensure that each one operates at its optimum level and has sufficient resources to minimize the occurrence of bottlenecks. Because database design is such an important factor in determining the database system’s performance efficiency, it is worth repeating this book’s mantra:</p>
<p class="calibre9"><strong class="calibre14">Good database performance starts with good database design.</strong>
<em class="italic">No amount of fine-tuning will make a poorly designed database perform as well as a well-designed database</em>. This is particularly true when redesigning existing databases, where the end user expects unrealistic performance gains from older databases.</p>
<p class="calibre9">What constitutes a good, efficient database design? From the performance-tuning point of view, the database designer must ensure that the design makes use of features in the DBMS that guarantee the integrity and optimal performance of the database. This chapter provides fundamental knowledge that will help you optimize database performance by selecting the appropriate database server configuration, using indexes, understanding table storage organization and data locations, and implementing the most efficient SQL query syntax.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1896913"></a>11.1.1 P<span><span class="calibre5">ERFORMANCE</span></span> T<span><span class="calibre5">UNING</span></span>: C<span><span class="calibre5">LIENT AND</span></span> S<span><span class="calibre5">ERVER</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">In general, database performance-tuning activities can be divided into those on the client side and those on the server side.</p>
<p class="calibre70">     •    On the client side, the objective is to generate a SQL query that returns the correct answer in the least amount of time, using the minimum amount of resources at the server end. The activities required to achieve that goal are commonly referred to as <a id="filepos1897645"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2867663"><strong class="calibre14">SQL performance tuning.</strong></a></p><div class="calibre3"> </div>
<p class="calibre72">     •     On the server side, the DBMS environment must be properly configured to respond to clients’ requests in the fastest way possible, while making optimum use of existing resources. The activities required to achieve that goal are commonly referred to as <a id="filepos1898051"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2770147"><strong class="calibre14">DBMS performance tuning.</strong></a></p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre35"><img alt="img" src="images/00023.jpg" class="calibre7"/> O<span><span class="calibre68">NLINE</span></span> C<span><span class="calibre68">ONTENT</span></span></span></p>
<p class="calibre9">If you want to learn more about clients and servers, check <strong class="calibre14">Appendix F, Client/Server Systems</strong>, at <a href="http://www.cengagebrain.com"><em class="italic">www.cengagebrain.com</em></a>.</p>
<hr class="calibre10"/><p class="calibre9">Keep in mind that DBMS implementations are typically more complex than just a two-tier client/server configuration. However, even in multitier client/server environments that consist of a client front end, application middleware, and database server back end, performance-tuning activities are frequently divided into subtasks to ensure the fastest possible response time between any two component points.</p>
<p class="calibre9">This chapter covers SQL performance-tuning practices on the client side and DBMS performance-tuning practices on the server side. However, before you start learning about the tuning processes, you must first learn more about the DBMS architectural components and processes, and how those processes interact to respond to end users’ requests.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1899543"></a>11.1.2 DBMS A<span><span class="calibre5">RCHITECTURE</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">The architecture of a DBMS is represented by the processes and structures (in memory and permanent storage) used to manage a database. Such processes collaborate with one another to perform specific functions. <a href="#filepos1900114">Figure 11.1</a> illustrates the basic DBMS architecture.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1900114"></a><strong class="calibre14">FIGURE 11.1 Basic DBMS architecture</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00449.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Note the following components and functions in <a href="#filepos1900114">Figure 11.1</a>:</p>
<p class="calibre71">     •    All data in a database are stored in <a id="filepos1900703"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2757745">data files</a>.</strong> A typical enterprise database is normally composed of several data files. A data file can contain rows from a single table, or it can contain rows from many different tables. A database administrator (DBA) determines the initial size of the data files that make up the database; however, the data files can automatically expand as required in predefined increments known as <a id="filepos1901140"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2789683"><strong class="calibre14">extends</strong></a>. For example, if more space is required, the DBA can define that each new extend will be in 10 KB or 10 MB increments.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Data files are generally grouped in file groups or table spaces. A <a id="filepos1901464"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2876605"><strong class="calibre14">table space</strong></a> or <a id="filepos1901530"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2793606">file group</a></strong> is a logical grouping of several data files that store data with similar characteristics. For example, you might have a <em class="italic">system</em> table space where the data dictionary table data are stored, a <em class="italic">user data</em> table space to store the user-created tables, an <em class="italic">index</em> table space to hold all indexes, and a <em class="italic">temporary</em> table space to do temporary sorts, grouping, and so on. Each time you create a new database, the DBMS automatically creates a minimum set of table spaces.</p><div class="calibre58"> </div>
<p class="calibre71">     •    The <a id="filepos1902170"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2755449"><strong class="calibre14">data cache</strong></a> or <a id="filepos1902235"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2737403"><strong class="calibre14">buffer cache</strong></a> is a shared, reserved memory area that stores the most recently accessed data blocks in RAM. The data read from the data files are stored in the data cache after the data have been read or before the data are written to the data files. The data cache also caches system catalog data and the contents of the indexes.</p><div class="calibre58"> </div>
<p class="calibre71">     •    The <a id="filepos1902698"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2867115"><strong class="calibre14">SQL cache</strong></a>, or <a id="filepos1902763"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2844370"><strong class="calibre14">procedure cache</strong></a>, is a shared, reserved memory area that stores the most recently executed SQL statements or PL/SQL procedures, including triggers and functions. (To learn more about PL/SQL procedures, triggers, and SQL functions, study <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_023.html#filepos1327332">Chapter 8</a>, Advanced SQL.) The SQL cache does not store the SQL written by the end user. Rather, the SQL cache stores a “processed” version of the SQL that is ready for execution by the DBMS.</p><div class="calibre58"> </div>
<p class="calibre71">     •    To work with the data, the DBMS must retrieve the data from permanent storage and place them in RAM. In other words, the data are retrieved from their data files and placed in the data cache.</p><div class="calibre58"> </div>
<p class="calibre71">     •    To move data from permanent storage (data files) to RAM (data cache), the DBMS issues I/O requests and waits for the replies. An <a id="filepos1903747"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2809177"><strong class="calibre14">input/output (I/O) request</strong></a> is a low-level data access operation that reads or writes data to and from computer devices, such as memory, hard disks, video, and printers. Note that an I/O disk read operation retrieves an entire physical disk block, generally containing multiple rows, from permanent storage to the data cache, even if you will use only one attribute from only one row. The physical disk block size depends on the operating system and could be 4K, 8K, 16K, 32K, 64K, or even larger. Furthermore, depending on the circumstances, a DBMS might issue a single-block read request or a multiblock read request.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Working with data in the data cache is many times faster than working with data in the data files because the DBMS does not have to wait for the hard disk to retrieve the data; no hard disk I/O operations are needed to work within the data cache.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Most performance-tuning activities focus on minimizing the number of I/O operations because using I/O operations is many times slower than reading data from the data cache. For example, as of this writing, RAM access times range from 5 to 70 nanoseconds, while hard disk access times range from 5 to 15 milliseconds. This means that hard disks are about six orders of magnitude (a million times) slower than RAM.</p><div class="calibre58"> </div>
<p class="calibre9"><a href="#filepos1900114">Figure 11.1</a> also illustrates some typical DBMS processes. Although the number of processes and their names vary from vendor to vendor, the functionality is similar. The following processes are represented in <a href="#filepos1900114">Figure 11.1</a>:</p>
<p class="calibre71">     •    <em class="italic">Listener</em>. The listener process listens for clients’ requests and handles the processing of the SQL requests to other DBMS processes. Once a request is received, the listener passes the request to the appropriate user process.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">User</em>. The DBMS creates a user process to manage each client session. Therefore, when you log on to the DBMS, you are assigned a user process. This process handles all requests you submit to the server. There are many user processes—at least one per logged-in client.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Scheduler</em>. The scheduler process organizes the concurrent execution of SQL requests. (See <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_028.html#filepos1760802">Chapter 10</a>, Transaction Management and Concurrency Control.)</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Lock manager</em>. This process manages all locks placed on database objects, including disk pages. (See <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_028.html#filepos1760802">Chapter 10</a>.)</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Optimizer</em>. The optimizer process analyzes SQL queries and finds the most efficient way to access the data. You will learn more about this process later in the chapter.</p><div class="calibre58"> </div>
<p class="calibre69"><span class="calibre8"><a id="filepos1907067"></a>11.1.3 D<span><span class="calibre5">ATABASE</span></span> Q<span><span class="calibre5">UERY</span></span> O<span><span class="calibre5">PTIMIZATION</span></span> M<span><span class="calibre5">ODES</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Most of the algorithms proposed for query optimization are based on two principles:</p>
<p class="calibre71">     •    The selection of the optimum execution order</p><div class="calibre58"> </div>
<p class="calibre71">     •    The selection of sites to be accessed to minimize communication costs</p><div class="calibre58"> </div>
<p class="calibre9">Within those two principles, a query optimization algorithm can be evaluated on the basis of its <em class="italic">operation mode</em> or the <em class="italic">timing of its optimization</em>.</p>
<p class="calibre9">Operation modes can be classified as manual or automatic. <a id="filepos1908055"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2732652"><strong class="calibre14">Automatic query optimization</strong></a> means that the DBMS finds the most cost-effective access path without user intervention. <a id="filepos1908224"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2819638"><strong class="calibre14">Manual query optimization</strong></a> requires that the optimization be selected and scheduled by the end user or programmer. Automatic query optimization is clearly more desirable from the end user’s point of view, but the cost of such convenience is the increased overhead that it imposes on the DBMS.</p>
<p class="calibre9">Query optimization algorithms can also be classified according to when the optimization is done. Within this timing classification, query optimization algorithms can be static or dynamic.</p>
<p class="calibre71">     •    <a id="filepos1908903"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2869274"><strong class="calibre14">Static query optimization</strong></a> takes place at compilation time. In other words, the best optimization strategy is selected when the query is compiled by the DBMS. This approach is common when SQL statements are embedded in procedural programming languages such as <em class="italic">C#</em> or Visual Basic .NET. When the program is submitted to the DBMS for compilation, it creates the plan necessary to access the database. When the program is executed, the DBMS uses that plan to access the database.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <a id="filepos1909517"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2780039"><strong class="calibre14">Dynamic query optimization</strong></a> takes place at execution time. Database access strategy is defined when the program is executed. Therefore, access strategy is dynamically determined by the DBMS at run time, using the most up-to-date information about the database. Although dynamic query optimization is efficient, its cost is measured by run-time processing overhead. The best strategy is determined every time the query is executed; this could happen several times in the same program.</p><div class="calibre58"> </div>
<p class="calibre9">Finally, query optimization techniques can be classified according to the type of information that is used to optimize the query. For example, queries may be based on statistically based or rule-based algorithms.</p>
<p class="calibre71">     •    A <a id="filepos1910414"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2869795"><strong class="calibre14">statistically based query optimization</strong></a> algorithm uses statistical information about the database. The statistics provide information about database characteristics such as size, number of records, average access time, number of requests serviced, and number of users with access rights. These statistics are then used by the DBMS to determine the best access strategy. Within statistically based optimizers, some DBMSs allow setting a goal to specify that the optimizer should attempt to minimize the time to retrieve the first row or the last row. Minimizing the time to retrieve the first row is often used in transaction systems and interactive client environments. In these cases, the goal is to present the first several rows to the user as quickly as possible. Then, while the DBMS waits for the user to scroll through the data, it can fetch the other rows for the query. Setting the optimizer goal to minimize retrieval of the last row is typically done in embedded SQL and inside stored procedures. In these cases, the control will not pass back to the calling application until all of the data have been retrieved; therefore, it is important to retrieve all of the data to the last row as quickly as possible so control can be returned.</p><div class="calibre58"> </div>
<p class="calibre71">     •    The statistical information is managed by the DBMS and is generated in one of two different modes: dynamic or manual. In the <a id="filepos1911915"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2780312"><strong class="calibre14">dynamic statistical generation mode</strong></a>, the DBMS automatically evaluates and updates the statistics after each access. In the <a id="filepos1912089"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2819894"><strong class="calibre14">manual statistical generation mode</strong></a>, the statistics must be updated periodically through a user-selected utility such as IBM’s RUNSTAT command, which is used by DB2 DBMSs.</p><div class="calibre58"> </div>
<p class="calibre71">     •    A <a id="filepos1912392"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2856813"><strong class="calibre14">rule-based query optimization algorithm</strong></a> is based on a set of user-defined rules to determine the best query access strategy. The rules are entered by the end user or database administrator, and they are typically general in nature.</p><div class="calibre58"> </div>
<p class="calibre9">Because database statistics play a crucial role in query optimization, this topic is explored in more detail in the next section.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1912943"></a>11.1.4 D<span><span class="calibre5">ATABASE</span></span> S<span><span class="calibre5">TATISTICS</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Another DBMS process that plays an important role in query optimization is gathering database statistics. The term <a id="filepos1913244"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2768994"><strong class="calibre14">database statistics</strong></a> refers to a number of measurements about database objects, such as number of processors used, processor speed, and temporary space available. Such statistics provide a snapshot of database characteristics.</p>
<p class="calibre9">As you will learn later in this chapter, the DBMS uses these statistics to make critical decisions about improving query processing efficiency. Database statistics can be gathered manually by the DBA or automatically by the DBMS. For example, many DBMS vendors support the ANALYZE command in SQL to gather statistics. In addition, many vendors have their own routines to gather statistics. For example, IBM’s DB2 uses the RUNSTATS procedure, while Microsoft’s SQL Server uses the UPDATE STATISTICS procedure and provides the Auto-Update and Auto-Create Statistics options in its initialization parameters. A sample of measurements that the DBMS may gather about various database objects is shown in <a href="#filepos1914458">Table 11.2</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos1914458"></a><strong class="calibre14">TABLE 11.2 Sample Database Statistics Measurements</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">DATABASE OBJECT</strong></p></td>
<td class="calibre62"><p class="calibre63"><strong class="calibre14">SAMPLE MEASUREMENTS</strong></p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Tables</p></td>
<td class="calibre62"><p class="calibre63">Number of rows, number of disk blocks used, row length, number of columns in each row, number of distinct values in each column, maximum value in each column, minimum value in each column, and columns that have indexes</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Indexes</p></td>
<td class="calibre62"><p class="calibre63">Number and name of columns in the index key, number of key values in the index, number of distinct key values in the index key, histogram of key values in an index, and number of disk pages used by the index</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Environment Resources</p></td>
<td class="calibre62"><p class="calibre63">Logical and physical disk block size, location and size of data files, and number of extends per data file</p></td></tr></div></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre9">If the object statistics exist, the DBMS will use them in query processing. Most newer DBMSs (such as Oracle, SQL Server, and DB2) automatically gather statistics; others require the DBA to gather statistics manually. To generate the database object statistics manually, you could use the following syntax:</p>
<p class="calibre9">ANALYZE &lt;TABLE/INDEX&gt; object_name COMPUTE STATISTICS;</p>
<p class="calibre9">In SQL Server, use UPDATE STATISTICS &lt;object_name&gt;, where object_name refers to a table or a view.</p>
<p class="calibre9">For example, to generate statistics for the VENDOR table, you would use the following command:</p>
<p class="calibre9">ANALYZE TABLE VENDOR COMPUTE STATISTICS;</p>
<p class="calibre9">In SQL Server, use UPDATE STATISTICS VENDOR;.</p>
<p class="calibre9">When you generate statistics for a table, all related indexes are also analyzed. However, you could generate statistics for a single index by using the following command:</p>
<p class="calibre9">ANALYZE INDEX VEND_NDX COMPUTE STATISTICS;</p>
<p class="calibre9">In the preceding example, VEND_NDX is the name of the index.</p>
<p class="calibre9">In SQL Server, use UPDATE STATISTICS &lt;table_name&gt; &lt;index_name&gt;. An example command would be UPDATE STATISTICS VENDOR VEND_NDX;.</p>
<p class="calibre9">Database statistics are stored in the system catalog in specially designated tables. It is common to periodically regenerate the statistics for database objects, especially database objects that are subject to frequent change. For example, if you own a video store and you have a video rental DBMS, your system will likely use a RENTAL table to store the daily video rentals. That RENTAL table and its associated indexes would be subject to constant inserts and updates as you record daily rentals and returns. Therefore, the RENTAL table statistics you generated last week do not accurately depict the table as it exists today. The more current the statistics are, the better the chances that the DBMS will properly select the fastest way to execute a given query.</p>
<p class="calibre9">Now that you know the basic architecture of DBMS processes and memory structures, and the importance and timing of the database statistics gathered by the DBMS, you are ready to learn how the DBMS processes a SQL query request.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1918840"></a>11.2 Q<span><span class="calibre68">UERY</span></span> P<span><span class="calibre68">ROCESSING</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">What happens at the DBMS server end when the client’s SQL statement is received? In simple terms, the DBMS processes a query in three phases:</p>
<p class="calibre79"><span class="calibre5">  1.  <em class="italic">Parsing</em>. The DBMS parses the SQL query and chooses the most efficient access/execution plan.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  <em class="italic">Execution</em>. The DBMS executes the SQL query using the chosen execution plan.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  3.  <em class="italic">Fetching</em>. The DBMS fetches the data and sends the result set back to the client.</span></p><div class="calibre3"> </div>
<p class="calibre9">The processing of SQL DDL statements (such as CREATE TABLE) is different from the processing required by DML statements. The difference is that a DDL statement actually updates the data dictionary tables or system catalog, while a DML statement (SELECT, INSERT, UPDATE, or DELETE) mostly manipulates end-user data. <a href="#filepos1920396">Figure 11.2</a> shows the general steps required for query processing. Each step will be discussed in the following sections.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1920396"></a><strong class="calibre14">FIGURE 11.2 Query processing</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00450.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><a id="filepos1920775"></a>11.2.1 SQL P<span><span class="calibre5">ARSING</span></span> P<span><span class="calibre5">HASE</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">The optimization process includes breaking down—parsing—the query into smaller units and transforming the original SQL query into a slightly different version of the original SQL code, but one that is fully equivalent and more efficient. <em class="italic">Fully equivalent</em> means that the optimized query results are always the same as the original query. <em class="italic">More efficient</em> means that the optimized query will almost always execute faster than the original query. (Note that it <em class="italic">almost</em> always executes faster because many factors affect the performance of a database, as explained earlier. Those factors include the network, the client computer’s resources, and other queries running concurrently in the same database.) To determine the most efficient way to execute the query, the DBMS may use the database statistics you learned about earlier.</p>
<p class="calibre9">The SQL parsing activities are performed by the <a id="filepos1921926"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2846337"><strong class="calibre14">query optimizer</strong></a>, which analyzes the SQL query and finds the most efficient way to access the data. This process is the most time-consuming phase in query processing. Parsing a SQL query requires several steps, in which the SQL query is:</p>
<p class="calibre71">     •    Validated for syntax compliance</p><div class="calibre58"> </div>
<p class="calibre71">     •    Validated against the data dictionary to ensure that table names and column names are correct</p><div class="calibre58"> </div>
<p class="calibre71">     •    Validated against the data dictionary to ensure that the user has proper access rights</p><div class="calibre58"> </div>
<p class="calibre71">     •    Analyzed and decomposed into more atomic components</p><div class="calibre58"> </div>
<p class="calibre71">     •    Optimized through transformation into a fully equivalent but more efficient SQL query</p><div class="calibre58"> </div>
<p class="calibre71">     •    Prepared for execution by determining the most efficient execution or access plan</p><div class="calibre58"> </div>
<p class="calibre9">Once the SQL statement is transformed, the DBMS creates what is commonly known as an access plan or execution plan. An <a id="filepos1923309"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2725723"><strong class="calibre14">access plan</strong></a> is the result of parsing a SQL statement; it contains the series of steps a DBMS will use to execute the query and return the result set in the most efficient way. First, the DBMS checks to see if an access plan already exists for the query in the SQL cache. If it does, the DBMS reuses the access plan to save time. If it does not, the optimizer evaluates various plans and then decides which indexes to use and how to best perform join operations. The chosen access plan for the query is then placed in the SQL cache and made available for use and future reuse.</p>
<p class="calibre9">Access plans are DBMS-specific and translate the client’s SQL query into the series of complex I/O operations required to read the data from the physical data files and generate the result set. <a href="#filepos1924518">Table 11.3</a> illustrates some I/O operations for an Oracle RDBMS. Most DBMSs perform similar types of operations when accessing and manipulating data sets.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><strong class="calibre14"><a id="filepos1924518"></a>TABLE 11.3 Sample DBMS Access Plan I/O Operations</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">OPERATION</strong></p></td>
<td class="calibre62"><p class="calibre63"><strong class="calibre14">DESCRIPTION</strong></p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Table scan (full)</p></td>
<td class="calibre62"><p class="calibre63">Reads the entire table sequentially, from the first row to the last, one row at a time (slowest)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Table access (row ID)</p></td>
<td class="calibre62"><p class="calibre63">Reads a table row directly, using the row ID value (fastest)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Index scan (range)</p></td>
<td class="calibre62"><p class="calibre63">Reads the index first to obtain the row IDs and then accesses the table rows directly (faster than a full table scan)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Index access (unique)</p></td>
<td class="calibre62"><p class="calibre63">Used when a table has a unique index in a column</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Nested loop</p></td>
<td class="calibre62"><p class="calibre63">Reads and compares a set of values to another set of values, using a nested loop style (slow)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Merge</p></td>
<td class="calibre62"><p class="calibre63">Merges two data sets (slow)</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">Sort</p></td>
<td class="calibre62"><p class="calibre63">Sorts a data set (slow)</p></td></tr></div></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre9">In <a href="#filepos1924518">Table 11.3</a>, note that a table access using a row ID is the fastest method. A row ID is a unique identification for every row saved in permanent storage; it can be used to access the row directly. Conceptually, a row ID is similar to a slip you get when you park your car in an airport parking lot. The parking slip contains the section number and lot number. Using that information, you can go directly to your car without searching every section and lot.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1926993"></a>11.2.2 SQL E<span><span class="calibre5">XECUTION</span></span> P<span><span class="calibre5">HASE</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">In this phase, all I/O operations indicated in the access plan are executed. When the execution plan is run, the proper locks—if needed—are acquired for the data to be accessed, and the data are retrieved from the data files and placed in the DBMS’s data cache. All transaction management commands are processed during the parsing and execution phases of query processing.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1927621"></a>11.2.3 SQL F<span><span class="calibre5">ETCHING</span></span> P<span><span class="calibre5">HASE</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">After the parsing and execution phases are completed, all rows that match the specified condition(s) are retrieved, sorted, grouped, and aggregated (if required). During the fetching phase, the rows of the resulting query result set are returned to the client. The DBMS might use temporary table space to store temporary data. In this stage, the database server coordinates the movement of the result set rows from the server cache to the client cache. For example, a given query result set might contain 9,000 rows; the server would send the first 100 rows to the client and then wait for the client to request the next set of rows, until the entire result set is sent to the client.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1928560"></a>11.2.4 Q<span><span class="calibre5">UERY</span></span> P<span><span class="calibre5">ROCESSING</span></span> B<span><span class="calibre5">OTTLENECKS</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">The main objective of query processing is to execute a given query in the fastest way possible with the least amount of resources. As you have seen, the execution of a query requires the DBMS to break down the query into a series of interdependent I/O operations to be executed in a collaborative manner. The more complex a query is, the more complex the operations are, which means that bottlenecks are more likely. A <a id="filepos1929209"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2846636"><strong class="calibre14">query processing bottleneck</strong></a> is a delay introduced in the processing of an I/O operation that causes the overall system to slow down. In the same way, the more components a system has, the more interfacing is required among the components, increasing the likelihood of bottlenecks. Within a DBMS, five components typically cause bottlenecks:</p>
<p class="calibre71">     •    <em class="italic">CPU</em>. The CPU processing power of the DBMS should match the system’s expected work load. A high CPU utilization might indicate that the processor speed is too slow for the amount of work performed. However, heavy CPU utilization can be caused by other factors, such as a defective component, not enough RAM (the CPU spends too much time swapping memory blocks), a badly written device driver, or a rogue process. A CPU bottleneck will affect not only the DBMS but all processes running in the system.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">RAM</em>. The DBMS allocates memory for specific usage, such as data cache and SQL cache. RAM must be shared among all running processes, including the operating system and DBMS. If there is not enough RAM available, moving data among components that are competing for scarce RAM can create a bottleneck.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Hard disk</em>. Other common causes of bottlenecks are hard disk speed and data transfer rates. Current hard disk storage technology allows for greater storage capacity than in the past; however, hard disk space is used for more than just storing end-user data. Current operating systems also use the hard disk for <em class="italic">virtual memory</em>, which refers to copying areas of RAM to the hard disk as needed to make room in RAM for more urgent tasks. Therefore, more hard disk storage space and faster data transfer rates reduce the likelihood of bottlenecks.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Network</em>. In a database environment, the database server and the clients are connected via a network. All networks have a limited amount of bandwidth that is shared among all clients. When many network nodes access the network at the same time, bottlenecks are likely.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Application code</em>. Not all bottlenecks are caused by limited hardware resources. Two of the most common sources of bottlenecks are inferior application code and poorly designed databases. Inferior code can be improved with code optimization techniques, as long as the underlying database design is sound. However, no amount of coding will make a poorly designed database perform better.</p><div class="calibre58"> </div>
<p class="calibre9">Learning how to avoid these bottlenecks and optimize database performance is the main focus of this chapter.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1932381"></a>11.3 I<span><span class="calibre68">NDEXES AND</span></span> Q<span><span class="calibre68">UERY</span></span> O<span><span class="calibre68">PTIMIZATION</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Indexes are crucial in speeding up data access because they facilitate searching, sorting, and using aggregate functions and even join operations. The improvement in data access speed occurs because an index is an ordered set of values that contains the index key and pointers. The pointers are the row IDs for the actual table rows. Conceptually, a data index is similar to a book index. When you use a book index, you look up a word, which is similar to the index key. The word is accompanied by one or more page numbers where the word is used; these numbers are similar to pointers.</p>
<p class="calibre9">An index scan is more efficient than a full table scan because the index data are preordered and the amount of data is usually much smaller. Therefore, when performing searches, it is almost always better for the DBMS to use the index to access a table than to scan all rows in a table sequentially. For example, <a href="#filepos1933870">Figure 11.3</a> shows the index representation of a CUSTOMER table with 14,786 rows and the index STATE_NDX on the CUS_STATE attribute.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1933870"></a><strong class="calibre14">FIGURE 11.3 Index representation for the CUSTOMER table</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00451.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Suppose you submit the following query:</p>
<div class="calibre58"> </div><table class="calibre59"><span class="calibre5">
<tr class="calibre61"><td class="calibre62">SELECT      CUS_NAME, CUS_STATE</td></tr><tr class="calibre61"><td class="calibre62">FROM         CUSTOMER</td></tr><tr class="calibre61"><td class="calibre62">WHERE       CUS_STATE = 'FL';</td></tr></span></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre9">If there is no index, the DBMS will perform a full table scan and read all 14,786 customer rows. Assuming that the index STATE_NDX is created (and analyzed), the DBMS will automatically use the index to locate the first customer with a state equal to 'FL' and then proceed to read all subsequent CUSTOMER rows, using the row IDs in the index as a guide. Assuming that only five rows meet the condition CUS_STATE = 'FL', there are five accesses to the index and five accesses to the data, for a total of 10 I/O accesses. The DBMS would save approximately 14,776 I/O requests for customer rows that do not meet the criteria. That is a lot of CPU cycles!</p>
<p class="calibre9">If indexes are so important, why not index every column in every table? The simple answer is that it is not practical to do so. Indexing every column in every table overtaxes the DBMS in terms of index-maintenance processing, especially if the table has many attributes and rows, or requires many inserts, updates, and deletes.</p>
<p class="calibre9">One measure that determines the need for an index is the data <em class="italic">sparsity</em> of the column you want to index. <a id="filepos1935843"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2763044">Data sparsity</a></strong> refers to the number of different values a column could have. For example, a STU_SEX column in a STUDENT table can have only two possible values, M or F; therefore, that column is said to have low sparsity. In contrast, the STU_DOB column that stores the student date of birth can have many different date values; therefore, that column is said to have high sparsity. Knowing the sparsity helps you decide whether the use of an index is appropriate. For example, when you perform a search in a column with low sparsity, you are likely to read a high percentage of the table rows anyway; therefore, index processing might be unnecessary work. In <a href="#filepos1950930">Section 11.5</a>, you learn how to determine when an index is recommended.</p>
<p class="calibre9">Most DBMSs implement indexes using one of the following data structures:</p>
<p class="calibre71">     •    <a id="filepos1936872"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2799897"><strong class="calibre14">Hash index</strong></a>. A hash index is based on an ordered list of hash values. A hash algorithm is used to create a hash value from a key column. This value points to an entry in a hash table, which in turn points to the actual location of the data row. This type of index is good for simple and fast lookup operations based on equality conditions—for example, LNAME=“Scott” and FNAME=“Shannon”.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <a id="filepos1937388"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2733228"><strong class="calibre14">B-tree index</strong></a>. The B-tree index is an ordered data structure organized as an upside-down tree. (See <a href="#filepos1940365">Figure 11.4</a>.) The index tree is stored separately from the data. The lower-level leaves of the B-tree index contain the pointers to the actual data rows. B-tree indexes are “self-balanced,” which means that it takes approximately the same amount of time to access any given row in the index. This is the default and most common type of index used in databases. The B-tree index is used mainly in tables in which column values repeat a relatively small number of times.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <a id="filepos1938113"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2735635"><strong class="calibre14">Bitmap index.</strong></a> A bitmap index uses a bit array (0s and 1s) to represent the existence of a value or condition. These indexes are used mostly in data warehouse applications in tables with a large number of rows in which a small number of column values repeat many times. (See <a href="#filepos1940365">Figure 11.4</a>.) Bitmap indexes tend to use less space than B-tree indexes because they use bits instead of bytes to store their data.</p><div class="calibre58"> </div>
<p class="calibre9">Using the preceding index characteristics, a database designer can determine the best type of index to use. For example, assume that a CUSTOMER table has several thousand rows. The CUSTOMER table has two columns that are used extensively for query purposes: CUS_LNAME, which represents a customer’s last name, and REGION_CODE, which can have one of four values (NE, NW, SW, and SE). Based on this information, you could conclude that:</p>
<p class="calibre71">     •    Because the CUS_LNAME column contains many different values that repeat a relatively small number of times compared to the total number of rows in the table, a B-tree index will be used.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Because the REGION_CODE column contains only a few different values that repeat a relatively large number of times compared to the total number of rows in the table, a bitmap index will be used. <a href="#filepos1940365">Figure 11.4</a> shows the B-tree and bitmap representations for the CUSTOMER table used in the previous discussion.</p><div class="calibre58"> </div>
<p class="calibre9">Current-generation DBMSs are intelligent enough to determine the best type of index to use under certain circumstances, provided that the DBMS has updated database statistics. Regardless of which index is chosen, the DBMS determines the best plan to execute a given query. The next section guides you through a simplified example of the type of choices the query optimizer must make.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1940365"></a><strong class="calibre14">FIGURE 11.4 B-tree and bitmap index representation</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00452.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1940854"></a>11.4 O<span><span class="calibre68">PTIMIZER</span></span> C<span><span class="calibre68">HOICES</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Query optimization is the central activity during the parsing phase in query processing. In this phase, the DBMS must choose what indexes to use, how to perform join operations, which table to use first, and so on. Each DBMS has its own algorithms for determining the most efficient way to access the data. The query optimizer can operate in one of two modes:</p>
<p class="calibre71">     •    <a id="filepos1941475"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2856597"><strong class="calibre14">A rule-based optimizer</strong></a> uses preset rules and points to determine the best approach to execute a query. The rules assign a “fixed cost” to each SQL operation; the costs are then added to yield the cost of the execution plan. For example, a full table scan has a set cost of 10, while a table access by row ID has a set cost of 3.</p><div class="calibre58"> </div>
<p class="calibre71">     •    A <a id="filepos1941936"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2750630"><strong class="calibre14">cost-based optimizer</strong></a> uses sophisticated algorithms based on statistics about the objects being accessed to determine the best approach to execute a query. In this case, the optimizer process adds up the processing cost, the I/O costs, and the resource costs (RAM and temporary space) to determine the total cost of a given execution plan.</p><div class="calibre58"> </div>
<p class="calibre9">The optimizer’s objective is to find alternative ways to execute a query—to evaluate the “cost” of each alternative and then to choose the one with the lowest cost. To understand the function of the query optimizer, consider a simple example. Assume that you want to list all products provided by a vendor based in Florida. To acquire that information, you could write the following query:</p>
<p class="calibre90">SELECT        P_CODE, P_DESCRIPT, P_PRICE, V_NAME, V_STATE</p>
<p class="calibre51">FROM           PRODUCT, VENDOR</p>
<p class="calibre51">WHERE         PRODUCT.V_CODE = VENDOR.V_CODE AND VENDOR.V_STATE = 'FL';</p>
<p class="calibre9">Furthermore, assume that the database statistics indicate the following:</p>
<p class="calibre71">     •    The PRODUCT table has 7,000 rows.</p><div class="calibre58"> </div>
<p class="calibre71">     •    The VENDOR table has 300 rows.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Ten vendors are located in Florida.</p><div class="calibre58"> </div>
<p class="calibre71">     •    One thousand products come from vendors in Florida.</p><div class="calibre58"> </div>
<p class="calibre9">It is important to point out that only the first two items are available to the optimizer. The second two items are assumed to illustrate the choices that the optimizer must make. Armed with the information in the first two items, the optimizer would try to find the most efficient way to access the data. The primary factor in determining the most efficient access plan is the I/O cost. (Remember, the DBMS always tries to minimize I/O operations.) <a href="#filepos1944543">Table 11.4</a> shows two sample access plans for the previous query and their respective I/O costs.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><strong class="calibre14"><a id="filepos1944543"></a>TABLE 11.4 Comparing Access Plans and I/O Costs</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00453.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre9">To make the example easier to understand, the I/O Operations and I/O Cost columns in <a href="#filepos1944543">Table 11.4</a> estimate only the number of I/O disk reads the DBMS must perform. For simplicity’s sake, it is assumed that there are no indexes and that each row read has an I/O cost of 1. For example, in step A1, the DBMS must calculate the Cartesian product of PRODUCT and VENDOR. To do that, the DBMS must read all rows from PRODUCT (7,000) and all rows from VENDOR (300), yielding a total of 7,300 I/O operations. The same computation is done in all steps. In <a href="#filepos1944543">Table 11.4</a>, you can see how plan A has a total I/O cost that is almost 30 times higher than plan B. In this case, the optimizer will choose plan B to execute the SQL.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63">N<span><span class="calibre8">OTE</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre53">Not all DBMSs optimize SQL queries the same way. As a matter of fact, Oracle parses queries differently from the methods described in several sections in this chapter. Always read the documentation to examine the optimization requirements for your DBMS implementation.</p></blockquote>
<hr class="calibre10"/><p class="calibre9">Given the right conditions, some queries could be answered entirely by using only an index. For example, assume that you are using the PRODUCT table and the index P_QOH_NDX in the P_QOH attribute. Then a query such as SELECT MIN(P_QOH) FROM PRODUCT could be resolved by reading only the first entry in the P_QOH_NDX index, without the need to access any of the data blocks for the PRODUCT table. (Remember that the index defaults to ascending order.)</p>
<p class="calibre9">You learned in <a href="#filepos1932381">Section 11.3</a> that columns with low sparsity are not good candidates for index creation. However, in some cases an index in a low-sparsity column would be helpful. For example, assume that the EMPLOYEE table has 122,483 rows. If you want to find out how many female employees work at the company, you would write a query such as:</p>
<p class="calibre9">SELECT COUNT(EMP_SEX) FROM EMPLOYEE WHERE EMP_SEX = 'F';</p>
<p class="calibre9">If you do not have an index for the EMP_SEX column, the query would have to perform a full table scan to read all EMPLOYEE rows—and each full row includes attributes you do not need. However, if you have an index on EMP_SEX, the query can be answered by reading only the index data, without the need to access the employee data at all.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1947660"></a>11.4.1 U<span><span class="calibre5">SING</span></span> H<span><span class="calibre5">INTS TO</span></span> A<span><span class="calibre5">FFECT</span></span> O<span><span class="calibre5">PTIMIZER</span></span> C<span><span class="calibre5">HOICES</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Although the optimizer generally performs very well under most circumstances, in some instances the optimizer might not choose the best execution plan. Remember, the optimizer makes decisions based on the existing statistics. If the statistics are old, the optimizer might not do a good job in selecting the best execution plan. Even with current statistics, the optimizer’s choice might not be the most efficient one. Sometimes the end user would like to change the optimizer mode for the current SQL statement. To do that, you need to use hints. <a id="filepos1948519"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2834057">Optimizer hints</a></strong> are special instructions for the optimizer that are embedded inside the SQL command text. <a href="#filepos1948918">Table 11.5</a> summarizes a few of the most common optimizer hints used in standard SQL.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos1948918"></a><strong class="calibre14">TABLE 11.5 Optimizer Hints</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">HINT</strong></p></td>
<td class="calibre62"><p class="calibre63">USAGE</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">ALL_ROWS</p></td><td class="calibre62"><p class="calibre63">Instructs the optimizer to minimize the overall execution time—that is, to minimize the time needed to return all rows in the query result set. This hint is generally used for batch mode processes. For example:<br class="calibre15"/> SELECT       /*+ ALL_ROWS */ * <br class="calibre15"/>FROM          PRODUCT<br class="calibre15"/> WHERE        P_QOH &lt; 10;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">FIRST_ROWS</p></td>
<td class="calibre62"><p class="calibre63">Instructs the optimizer to minimize the time needed to process the first set of rows—that is, to minimize the time needed to return only the first set of rows in the query result set. This hint is generally used for interactive mode processes. For example:<br class="calibre15"/> SELECT        /*+ FIRST_ROWS */ *<br class="calibre15"/> FROM           PRODUCT <br class="calibre15"/>WHERE         P_QOH &lt; 10;</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">INDEX(name)</p></td>
<td class="calibre62"><p class="calibre63">Forces the optimizer to use the P_QOH_NDX index to process this query. For example:<br class="calibre15"/> SELECT         /*+ INDEX(P_QOH_NDX) */ *<br class="calibre15"/> FROM           PRODUCT <br class="calibre15"/>WHERE         P_QOH &lt; 10;</p></td></tr></div></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre9">Now that you are familiar with the way the DBMS processes SQL queries, you can turn your attention to some general SQL coding recommendations to facilitate the work of the query optimizer.</p>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1950930"></a>11.5 SQL P<span><span class="calibre68">ERFORMANCE</span></span> T<span><span class="calibre68">UNING</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">SQL performance tuning is evaluated from the client perspective. Therefore, the goal is to illustrate some common practices used to write efficient SQL code. A few words of caution are appropriate:</p>
<p class="calibre71">     •    Most current-generation relational DBMSs perform automatic query optimization at the server end.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Most SQL performance optimization techniques are DBMS-specific and therefore are rarely portable, even across different versions of the same DBMS. Part of the reason for this behavior is the constant advancement in database technologies.</p><div class="calibre58"> </div>
<p class="calibre9">Does this mean that you should not worry about how a SQL query is written because the DBMS will always optimize it? No, because there is considerable room for improvement. (The DBMS uses <em class="italic">general</em> optimization techniques rather than focusing on specific techniques dictated by the special circumstances of the query execution.) A poorly written SQL query can, <em class="italic">and usually will</em>, bring the database system to its knees from a performance point of view. The majority of current database performance problems are related to poorly written SQL code. Therefore, although a DBMS provides general optimizing services, a carefully written query almost always outperforms a poorly written one.</p>
<p class="calibre9">Although SQL data manipulation statements include many different commands such as INSERT, UPDATE, DELETE, and SELECT, most recommendations in this section are related to the use of the SELECT statement, and in particular, the use of indexes and how to write conditional expressions.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1952998"></a>11.5.1 I<span><span class="calibre5">NDEX</span></span> S<span><span class="calibre5">ELECTIVITY</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Indexes are the most important technique used in SQL performance optimization. The key is to know when an index is used. As a general rule, indexes are likely to be used:</p>
<p class="calibre71">     •    When an indexed column appears by itself in the search criteria of a WHERE or HAVING clause.</p><div class="calibre58"> </div>
<p class="calibre71">     •    When an indexed column appears by itself in a GROUP BY or ORDER BY clause.</p><div class="calibre58"> </div>
<p class="calibre71">     •    When a MAX or MIN function is applied to an indexed column.</p><div class="calibre58"> </div>
<p class="calibre71">     •    When the data sparsity on the indexed column is high.</p><div class="calibre58"> </div>
<p class="calibre9">Indexes are very useful when you want to select a small subset of rows from a large table based on a given condition. If an index exists for the column used in the selection, the DBMS may choose to use it. The objective is to create indexes with high selectivity. <a id="filepos1954284"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2805610"><strong class="calibre14">Index selectivity</strong></a> is a measure of the likelihood that an index will be used in query processing. Here are some general guidelines for creating and using indexes:</p>
<p class="calibre71">     •    <em class="italic">Create indexes for each single attribute used in a WHERE, HAVING, ORDER BY, or GROUP BY clause</em>. If you create indexes in all single attributes <em class="italic">used in search conditions</em>, the DBMS will access the table using an index scan instead of a full table scan. For example, if you have an index for P_PRICE, the condition P_PRICE &gt; 10.00 can be solved by accessing the index instead of sequentially scanning all table rows and evaluating P_PRICE for each row. Indexes are also used in join expressions, such as in CUSTOMER.CUS_CODE = INVOICE.CUS_CODE.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Do not use indexes in small tables or tables with low sparsity</em>. Remember, small tables and low-sparsity tables are not the same thing. A search condition in a table with low sparsity may return a high percentage of table rows anyway, making the index operation too costly and making the full table scan a viable option. Using the same logic, do not create indexes for tables with few rows and few attributes—<em class="italic">unless you must ensure the existence of unique values in a column</em>.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Declare primary and foreign keys so the optimizer can use the indexes in join operations</em>. All natural joins and old-style joins will benefit if you declare primary keys and foreign keys because the optimizer will use the available indexes at join time. (The declaration of a PK or FK will automatically create an index for the declared column.) Also, for the same reason, it is better to write joins using the SQL JOIN syntax. (See <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_023.html#filepos1327332">Chapter 8</a>, Advanced SQL.)</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Declare indexes in join columns other than PK or FK</em>. If you perform join operations on columns other than the primary and foreign keys, you might be better off declaring indexes in those columns.</p><div class="calibre58"> </div>
<p class="calibre9">You cannot always use an index to improve performance. For example, using the data shown in <a href="#filepos1959032">Table 11.6</a> in the next section, the creation of an index for P_MIN will not help the search condition P_QOH &gt; P_MIN * 1.10. The reason is that in some DBMSs, <em class="italic">indexes are ignored when you use functions in the table attributes</em>. However, major databases such as Oracle, SQL Server, and DB2 now support function-based indexes. A <a id="filepos1957087"></a><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2797623"><strong class="calibre14">function-based index</strong></a> is an index based on a specific SQL function or expression. For example, you could create an index on YEAR(INV_DATE). Function-based indexes are especially useful when dealing with derived attributes. For example, you could create an index on EMP_SALARY + EMP_COMMISSION.</p>
<p class="calibre9">How many indexes should you create? It bears repeating that you should not create an index for every column in a table. Too many indexes will slow down INSERT, UPDATE, and DELETE operations, especially if the table contains many thousands of rows. Furthermore, some query optimizers will choose only one index to be the driving index for a query, even if your query uses conditions in many different indexed columns. Which index does the optimizer use? If you use the cost-based optimizer, the answer will change with time as new rows are added to or deleted from the tables. In any case, you should create indexes in all search columns and then let the optimizer choose. It is important to constantly evaluate the index usage—monitor, test, evaluate, and improve it if performance is not adequate.</p>
<p class="calibre69"><span class="calibre8"><a id="filepos1958368"></a>11.5.2 C<span><span class="calibre5">ONDITIONAL</span></span> E<span><span class="calibre5">XPRESSIONS</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">A conditional expression is normally placed within the WHERE or HAVING clauses of a SQL statement. Also known as conditional criteria, a conditional expression restricts the output of a query to only the rows that match the conditional criteria. Generally, the conditional criteria have the form shown in <a href="#filepos1959032">Table 11.6</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos1959032"></a><strong class="calibre14">TABLE 11.6 Conditional Criteria</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">OPERAND1</strong></p></td>
<td class="calibre62"><p class="calibre63"><strong class="calibre14">CONDITIONAL OPERATOR</strong></p></td>
<td class="calibre62"><p class="calibre63"><strong class="calibre14">OPERAND2</strong></p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">P_PRICE</p></td>
<td class="calibre62"><p class="calibre63">&gt;</p></td>
<td class="calibre62"><p class="calibre63">10.00</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">V_STATE</p></td>
<td class="calibre62"><p class="calibre63">=</p></td>
<td class="calibre62"><p class="calibre63">FL</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">V_CONTACT</p></td>
<td class="calibre62"><p class="calibre63">LIKE</p></td>
<td class="calibre62"><p class="calibre63">Smith%</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63">P_QOH</p></td>
<td class="calibre62"><p class="calibre63">&gt;</p></td>
<td class="calibre62"><p class="calibre63">P_MIN * 1.10</p></td></tr></div></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre9">In <a href="#filepos1959032">Table 11.6</a>, note that an operand can be:</p>
<p class="calibre71">     •    A simple column name such as P_PRICE or V_STATE</p><div class="calibre58"> </div>
<p class="calibre71">     •    A literal or a constant such as the value 10.00 or the text 'FL'</p><div class="calibre58"> </div>
<p class="calibre71">     •    An expression such as P_MIN * 1.10</p><div class="calibre58"> </div>
<p class="calibre9">Most of the query optimization techniques mentioned next are designed to make the optimizer’s work easier. The following common practices are used to write efficient conditional expressions in SQL code.</p>
<p class="calibre71">     •    <em class="italic">Use simple columns or literals as operands in a conditional expression—avoid the use of conditional expressions with functions whenever possible</em>. Comparing the contents of a single column to a literal is faster than comparing to expressions. For example, P_PRICE &gt; 10.00 is faster than P_QOH &gt; P_MIN * 1.10 because the DBMS must evaluate the P_MIN * 1.10 expression first. The use of functions in expressions also adds to the total query execution time. For example, if your condition is UPPER (V_NAME) = ‘JIM’, try to use V_NAME = ‘JIM’ if all names in the V_NAME column are stored with proper capitalization.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Numeric field comparisons are faster than character, date, and NULL comparisons</em>. In search conditions, comparing a numeric attribute to a numeric literal is faster than comparing a character attribute to a character literal. In general, the CPU handles numeric comparisons (integer and decimal) faster than character and date comparisons. Because indexes do not store references to null values, NULL conditions involve additional processing, and therefore tend to be the slowest of all conditional operands.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Equality comparisons are generally faster than inequality comparisons</em>. For example, P_PRICE = 10.00 is processed faster because the DBMS can do a direct search using the index in the column. If there are no exact matches, the condition is evaluated as false. However, if you use an inequality symbol (&gt;, &gt;=, &lt;, &lt;=), the DBMS must perform additional processing to complete the request, because there will almost always be more “greater than” or “less than” values in the index than “equal” values. With the exception of NULL, the slowest of all comparison operators is LIKE with wildcard symbols, as in V_CONTACT LIKE “%glo%”. Also, using the “not equal” symbol (&lt;&gt;) yields slower searches, especially when the sparsity of the data is high—that is, when there are many more different values than there are equal values.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Whenever possible, transform conditional expressions to use literals</em>. For example, if your condition is P_PRICE - 10 = 7, change it to read P_PRICE = 17. Also, if you have a composite condition such as:</p><div class="calibre58"> </div>
<blockquote class="calibre29"><p class="calibre79">    P_QOH &lt; P_MIN AND P_MIN = P_REORDER AND P_QOH = 10</p></blockquote>
<blockquote class="calibre29"><p class="calibre81">    change it to read:</p></blockquote>
<blockquote class="calibre29"><p class="calibre79">    P_QOH = 10 AND P_MIN = P_REORDER AND P_MIN &gt; 10</p></blockquote>
<p class="calibre71">     •    <em class="italic">When using multiple conditional expressions, write the equality conditions first</em>. Note that this was done in the previous example. Remember, equality conditions are faster to process than inequality conditions. Although most RDBMSs will automatically do this for you, paying attention to this detail lightens the load for the query optimizer. The optimizer will not have to do what you have already done.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">If you use multiple AND conditions, write the condition most likely to be false first</em>. If you use this technique, the DBMS will stop evaluating the rest of the conditions as soon as it finds a conditional expression that is evaluated as false. Remember, for multiple AND conditions to be found true, all conditions must be evaluated as true. If one of the conditions evaluates to false, the whole set of conditions will be evaluated as false. If you use this technique, the DBMS will not waste time unnecessarily evaluating additional conditions. Naturally, the use of this technique implies knowledge of the sparsity of the data set. For example, look at the following condition list:</p><div class="calibre58"> </div>
<p class="calibre71">     •    P_PRICE &gt; 10 AND V_STATE = 'FL'</p><div class="calibre58"> </div>
<p class="calibre70">    If you know that only a few vendors are located in Florida, you could rewrite this condition as:</p><div class="calibre3"> </div>
<p class="calibre72">    V_STATE = 'FL' AND P_PRICE &gt; 10</p>
<p class="calibre71">     •    <em class="italic">When using multiple OR conditions, put the condition most likely to be true first</em>. By doing this, the DBMS will stop evaluating the remaining conditions as soon as it finds a conditional expression that is evaluated as true. Remember, for multiple OR conditions to evaluate to true, only one of the conditions must be evaluated as true.</p><div class="calibre58"> </div>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63">N<span><span class="calibre8">OTE</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre53">Oracle does not evaluate queries as described here. Instead, Oracle evaluates conditions from last to first.</p></blockquote>
<hr class="calibre10"/><p class="calibre71">     •    <em class="italic">Whenever possible, try to avoid the use of the NOT logical operator</em>. It is best to transform a SQL expression that contains a NOT logical operator into an equivalent expression. For example:</p><div class="calibre58"> </div>
<blockquote class="calibre29"><p class="calibre79">    NOT (P_PRICE &gt; 10.00) can be written as P_PRICE &lt;= 10.00.</p></blockquote>
<blockquote class="calibre29"><p class="calibre81">    Also, NOT (EMP_SEX = 'M') can be written as EMP_SEX = 'F'.</p></blockquote>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1967241"></a>11.6 Q<span><span class="calibre68">UERY</span></span> F<span><span class="calibre68">ORMULATION</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Queries are usually written to answer questions. For example, if an end user gives you a sample output and tells you to match that output format, you must write the corresponding SQL. To get the job done, you must carefully evaluate what columns, tables, and computations are required to generate the desired output. To do that, you must have a good understanding of the database environment and the database that will be the focus of your SQL code.</p>
<p class="calibre9">This section focuses on SELECT queries because they are the queries you will find in most applications. To formulate a query, you would normally follow these steps:</p>
<p class="calibre79"><span class="calibre5">  1.  <em class="italic">Identify what columns and computations are required</em>. The first step is needed to clearly determine what data values you want to return. Do you want to return just the names and addresses, or do you also want to include some computations? Remember that all columns in the SELECT statement should return single values.</span></p><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">a.   Do you need simple expressions? For example, do you need to multiply the price by the quantity on hand to generate the total inventory cost? You might need some single attribute functions such as DATE(), SYSDATE(), or ROUND().</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">b.   Do you need aggregate functions? If you need to compute the total sales by product, you should use a GROUP BY clause. In some cases, you might need to use a subquery.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">c.   Determine the granularity of the raw data required for your output. Sometimes, you might need to summarize data that are not readily available in any table. In such cases, you might consider breaking the query into multiple subqueries and storing those subqueries as views. Then you could create a top-level query that joins those views and generates the final output.</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  <em class="italic">Identify the source tables</em>. Once you know what columns are required, you can determine the source tables used in the query. Some attributes appear in more than one table. In those cases, try to use the least number of tables in your query to minimize the number of join operations.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  3.  <em class="italic">Determine how to join the tables</em>. Once you know what tables you need in your query statement, you must properly identify how to join the tables. In most cases, you will use some type of natural join, but in some instances, you might need to use an outer join.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  4.  <em class="italic">Determine what selection criteria are needed</em>. Most queries involve some type of selection criteria. In this case, you must determine what operands and operators are needed in your criteria. Ensure that the data type and granularity of the data in the comparison criteria are correct.</span></p><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">a.   <em class="italic">Simple comparison</em>. In most cases, you will be comparing single values—for example, P_PRICE &gt; 10.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">b.   <em class="italic">Single value to multiple values</em>. If you are comparing a single value to multiple values, you might need to use an IN comparison operator—for example, V_STATE IN ('FL', 'TN', 'GA').</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">c.   <em class="italic">Nested comparisons</em>. In other cases, you might need to have some nested selection criteria involving subqueries—for example, P_PRICE &gt;= (SELECT AVG(P_PRICE) FROM PRODUCT).</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">d.   <em class="italic">Grouped data selection</em>. On other occasions, the selection criteria might apply not to the raw data but to the aggregate data. In those cases, you need to use the HAVING clause.</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  5.  <em class="italic">Determine the order in which to display the output</em>. Finally, the required output might be ordered by one or more columns. In those cases, you need to use the ORDER BY clause. Remember that the ORDER BY clause is one of the most resource-intensive operations for the DBMS.</span></p><div class="calibre3"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1972558"></a>11.7 DBMS P<span><span class="calibre68">ERFORMANCE</span></span> T<span><span class="calibre68">UNING</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">DBMS performance tuning includes global tasks such as managing the DBMS processes in primary memory (allocating memory for caching purposes) and managing the structures in physical storage (allocating space for the data files).</p>
<p class="calibre9">Fine-tuning the performance of the DBMS also includes applying several practices examined in the previous section. For example, the DBA must work with developers to ensure that the queries perform as expected—creating the indexes to speed up query response time and generating the database statistics required by cost-based optimizers.</p>
<p class="calibre9">DBMS performance tuning at the server end focuses on setting the parameters used for:</p>
<p class="calibre71">     •    <em class="italic">Data cache</em>. The data cache size must be set large enough to permit as many data requests as possible to be serviced from the cache. Each DBMS has settings that control the size of the data cache; some DBMSs might require a restart. This cache is shared among all database users. The majority of primary memory resources will be allocated to the data cache.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">SQL cache</em>. The SQL cache stores the most recently executed SQL statements (after the SQL statements have been parsed by the optimizer). Generally, if you have an application with multiple users accessing a database, the <em class="italic">same</em> query will likely be submitted by many different users. In those cases, the DBMS will parse the query only once and execute it many times, using the same access plan. In that way, the second and subsequent SQL requests for the same query are served from the SQL cache, skipping the parsing phase.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Sort cache</em>. The sort cache is used as a temporary storage area for ORDER BY or GROUP BY operations, as well as for index-creation functions.</p><div class="calibre58"> </div>
<p class="calibre71">     •    <em class="italic">Optimizer mode</em>. Most DBMSs operate in one of two optimization modes: cost-based or rule-based. Others automatically determine the optimization mode based on whether database statistics are available. For example, the DBA is responsible for generating the database statistics that are used by the cost-based optimizer. If the statistics are not available, the DBMS uses a rule-based optimizer.</p><div class="calibre58"> </div>
<p class="calibre9">Managing the physical storage details of the data files also plays an important role in DBMS performance tuning. Note the following general recommendations for physical storage of databases:</p>
<p class="calibre71">     •    Use <a id="filepos1975651"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2847213">RAID</a></strong> (redundant array of independent disks) to provide both performance improvement and fault tolerance, and a balance between them. Fault tolerance means that in case of failure, data can be reconstructed and retrieved. RAID systems use multiple disks to create virtual disks (storage volumes) formed by several individual disks. <a href="#filepos1976248">Table 11.7</a> describes the most common RAID configurations.</p><div class="calibre58"> </div>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos1976248"></a><strong class="calibre14">TABLE 11.7 Common RAID Levels</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><div class="calibre58"> </div><table class="calibre59"><div class="calibre5">
<tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">RAID LEVEL</strong></p></td><td class="calibre62"><p class="calibre63"><strong class="calibre14">DESCRIPTION</strong></p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">0</strong></p></td><td class="calibre62"><p class="calibre63">The data blocks are spread over separate drives. Also known as striped array. Provides increased performance but no fault tolerance. Requires a minimum of two drives.</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">1</strong></p></td><td class="calibre62"><p class="calibre63">The same data blocks are written (duplicated) to separate drives. Also referred to as mirroring or duplexing. Provides increased read performance and fault tolerance via data redundancy. Requires a minimum of two drives.</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">3</strong></p></td><td class="calibre62"><p class="calibre63">The data are striped across separate drives, and parity data are computed and stored in a dedicated drive. (Parity data are specially generated data that permit the reconstruction of corrupted or missing data.) Provides good read performance and fault tolerance via parity data. Requires a minimum of three drives.</p></td></tr><tr class="calibre61"><td class="calibre62"><p class="calibre63"><strong class="calibre14">5</strong></p></td><td class="calibre62"><p class="calibre63">The data and the parity data are striped across separate drives. Provides good read performance and fault tolerance via parity data. Requires a minimum of three drives.</p></td></tr></div></table><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre71">     •    Minimize disk contention. Use multiple, independent storage volumes with independent spindles (rotating disks) to minimize hard disk cycles. Remember, a database is composed of many table spaces, each with a particular function. In turn, each table space is composed of several data files in which the data are actually stored. A database should have at least the following table spaces:</p><div class="calibre58"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    <em class="italic">System table space</em>. This is used to store the data dictionary tables. It is the most frequently accessed table space and should be stored in its own volume.</span></p></blockquote><div class="calibre23"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    <em class="italic">User data table space</em>. This is used to store end-user data. You should create as many user data table spaces and data files as are required to balance performance and usability. For example, you can create and assign a different user data table space for each application and each distinct group of users, but this is not necessary for each user.</span></p></blockquote><div class="calibre23"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    <em class="italic">Index table space</em>. This is used to store indexes. You can create and assign a different index table space for each application and each group of users. The index table space data files should be stored on a storage volume that is separate from user data files or system data files.</span></p></blockquote><div class="calibre23"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    <em class="italic">Temporary table space</em>. This is used as a temporary storage area for merge, sort, or set aggregate operations. You can create and assign a different temporary table space for each application and each group of users.</span></p></blockquote><div class="calibre23"> </div>
<blockquote class="calibre29"><p class="calibre91"><span class="calibre5">-    <em class="italic">Rollback segment table space</em>. This is used for transaction-recovery purposes.</span></p></blockquote><div class="calibre23"> </div>
<p class="calibre71">     •    Put high-usage tables in their own table spaces so the database minimizes conflict with other tables.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Assign separate data files in separate storage volumes for the indexes, system, and high-usage tables. This ensures that index operations will not conflict with end-user data or data dictionary table access operations. Another advantage of this approach is that you can use different disk block sizes in different volumes. For example, the data volume can use a 16 K block size, while the index volume can use an 8 K block size. Remember that the index record size is generally smaller, and by changing the block size you will reduce contention and minimize I/O operations. This is very important; many database administrators overlook indexes as a source of contention. By using separate storage volumes and different block sizes, the I/O operations on data and indexes will happen asynchronously (at different times); more importantly, the likelihood of write operations blocking read operations is reduced, as page locks tend to lock fewer records.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Take advantage of the various table storage organizations available in the database. For example, in Oracle consider the use of index-organized tables (IOT); in SQL Server, consider clustered index tables. An <a id="filepos1981760"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2805291">index-organized table</a></strong> (or <a id="filepos1981837"></a><strong class="calibre14"><a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_038.html#filepos2743913">clustered index table</a></strong>) is a table that stores the end-user data and the index data in consecutive locations on permanent storage. This type of storage organization provides a performance advantage to tables that are commonly accessed through a given index order, because the index contains the index key as well as the data rows. Therefore, the DBMS tends to perform fewer I/O operations.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Partition tables based on usage. Some RDBMSs support the horizontal partitioning of tables based on attributes. (See <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_030.html#filepos2024073">Chapter 12</a>, Distributed Database Management Systems.) By doing so, a single SQL request can be processed by multiple data processors. Put the table partitions closest to where they are used the most.</p><div class="calibre58"> </div>
<p class="calibre71">     •    Use denormalized tables where appropriate. In other words, you might be able to improve performance by taking a table from a higher normal form to a lower normal form—typically, from third to second normal form. This technique adds data duplication, but it minimizes join operations. (Denormalization was discussed in <a href="CR%215A4MGEVRHD03Z2219SKHVZ3J0KMH_split_018.html#filepos861217">Chapter 6</a>, Normalization of Database Tables.)</p><div class="calibre58"> </div>
<p class="calibre71">     •    Store computed and aggregate attributes in tables. In short, use derived attributes in your tables. For example, you might add the invoice subtotal, the amount of tax, and the total in the INVOICE table. Using derived attributes minimizes computations in queries and join operations.</p><div class="calibre58"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre22"><span class="calibre35"><a id="filepos1983690"></a>11.8 Q<span><span class="calibre68">UERY</span></span> O<span><span class="calibre68">PTIMIZATION</span></span> E<span><span class="calibre68">XAMPLE</span></span></span></p>
<hr class="calibre10"/><p class="calibre9">Now that you have learned the basis of query optimization, you are ready to test your new knowledge. A simple example illustrates how the query optimizer works and how you can help it work. The example is based on the QOVENDOR and QOPRODUCT tables, which are similar to tables you used in previous chapters. However, the QO prefix is used for the table name to ensure that you do not overwrite previous tables.</p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre35"><img alt="img" src="images/00023.jpg" class="calibre7"/> O<span><span class="calibre68">NLINE</span></span> C<span><span class="calibre68">ONTENT</span></span></span></p>
<p class="calibre9">The databases and scripts used in this chapter are available at <em class="italic"><a href="http://www.cengagebrain.com">www.cengagebrain.com</a></em>.</p>
<hr class="calibre10"/><p class="calibre9">To perform this query optimization example, you will use the Oracle SQL*Plus interface. Some preliminary work must be done before you can start testing query optimization, as explained in the following steps:</p>
<p class="calibre79"><span class="calibre5">  1.  Log in to Oracle SQL*Plus using the username and password provided by your instructor.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  Create a fresh set of tables, using the QRYOPTDATA.SQL script file at <em class="italic"><a href="http://www.cengagebrain.com">www.cengagebrain.com</a></em>. This step is necessary so that Oracle has a new set of tables and the new tables contain no statistics. At the SQL&gt; prompt, type:</span></p><div class="calibre3"> </div>
<p class="calibre9">           @path\QRYOPTDATA.SQL</p>
<p class="calibre9">          where <em class="italic">path</em> is the location of the file in your computer.</p>
<p class="calibre79"><span class="calibre5">  3.  Create the PLAN_TABLE, which is a special table used by Oracle to store the access plan information for a given query. End users can then query the PLAN_TABLE to see how Oracle will execute the query. To create the PLAN_TABLE, run the UTLXPLAN.SQL script file in the RDBMS\ADMIN folder of your Oracle RDBMS installation. The UTLXPLAN.SQL script file is also available at <a href="http://www.cengagebrain.com"><em class="italic">www.cengagebrain.com</em></a>. At the SQL prompt, type:</span></p><div class="calibre3"> </div>
<p class="calibre9">           @path\UTLXPLAN.SQL</p>
<p class="calibre9">You use the EXPLAIN PLAN command to store the execution plan of a SQL query in the PLAN_TABLE. Then, you use the SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY) command to display the access plan for a given SQL statement.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63">N<span><span class="calibre8">OTE</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre53">Oracle 11g automatically defaults to cost-based optimization without giving you a choice. Oracle versions prior to Oracle 10g default to the Choose optimization mode, which implies that the DBMS will choose either rule-based or cost-based optimization, depending on the availability of table statistics.</p></blockquote>
<hr class="calibre10"/><p class="calibre9">To see the access plan used by the DBMS to execute your query, use the EXPLAIN PLAN and SELECT statements, as shown in <a href="#filepos1987930">Figure 11.5</a>. Note that the first SQL statement generates the statistics for the QOVENDOR table. Also, the initial access plan in <a href="#filepos1987930">Figure 11.5</a> uses a full table scan on the QOVENDOR table, and the cost of the plan is 4.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1987930"></a><strong class="calibre14">FIGURE 11.5 Initial explain plan</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00454.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Now create an index on V_AREACODE (note that V_AREACODE is used in the ORDER BY clause) and see how it affects the access plan generated by the cost-based optimizer. The results are shown in <a href="#filepos1988676">Figure 11.6</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1988676"></a><strong class="calibre14">FIGURE 11.6 Explain plan after index on V_AREACODE</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00455.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">In <a href="#filepos1988676">Figure 11.6</a>, note that the new access plan cuts the cost of executing the query by half! Also note that this new plan scans the QOV_NDX1 index and accesses the QOVENDOR rows, using the index row ID. (Remember that access by row ID is one of the fastest access methods.) In this case, the creation of the QOV_NDX1 index had a positive impact on overall query optimization results.</p>
<p class="calibre9">At other times, indexes do not necessarily help in query optimization, such as when you have indexes on small tables or when the query accesses a great percentage of table rows anyway. Note what happens when you create an index on V_NAME. The new access plan is shown in <a href="#filepos1990083">Figure 11.7</a>. (Note that V_NAME is used on the WHERE clause as a conditional expression operand.)</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1990083"></a><strong class="calibre14">FIGURE 11.7 Explain plan after index on V_NAME</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00456.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">As you can see in <a href="#filepos1990083">Figure 11.7</a>, creation of the second index did not help the query optimization. However, on some occasions an index might be used by the optimizer, but it is not executed because of the way the query is written. For example, <a href="#filepos1990989">Figure 11.8</a> shows the access plan for a different query using the V_NAME column.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1990989"></a><strong class="calibre14">FIGURE 11.8 Access plan using index on V_NAME</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00457.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">In <a href="#filepos1990989">Figure 11.8</a>, note that the access plan for this new query uses the QOV_NDX2 index on the V_NAME column. What would happen if you wrote the same query, using the UPPER function on V_NAME? The results are illustrated in <a href="#filepos1991805">Figure 11.9</a>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1991805"></a><strong class="calibre14">FIGURE 11.9 Access plan using functions on indexed columns</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00458.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">As <a href="#filepos1991805">Figure 11.9</a> shows, the use of a function on an indexed column caused the DBMS to perform additional operations that increased the cost of the query. The same query might produce different costs if your tables contain many more rows and if the index sparsity is different.</p>
<p class="calibre9">Now use the QOPRODUCT table to demonstrate how an index can help when aggregate function queries are being run. For example, <a href="#filepos1993027">Figure 11.10</a> shows the access plan for a SELECT statement using the MAX(P_PRICE) aggregate function. This plan uses a full table scan with a total cost of 3.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1993027"></a><strong class="calibre14">FIGURE 11.10 First explain plan: aggregate function on a non-indexed column</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00459.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">A cost of 3 is very low already, but you could improve the previous query performance by creating an index on P_PRICE. <a href="#filepos1994008">Figure 11.11</a> shows how the plan cost is reduced by two-thirds after the index is created and the QOPRODUCT table is analyzed. Also note that the second version of the access plan uses only the index QOP_NDX2 to answer the query; <em class="italic">the QOPRODUCT table is never accessed</em>.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1994008"></a><strong class="calibre14">FIGURE 11.11 Second explain plan: aggregate function on an indexed column</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00460.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">Although the few examples in this section show the importance of proper index selection for query optimization, you also saw examples in which index creation does not improve query performance. As a DBA, you should be aware that the main goal is to optimize overall database performance—not just for a single query but for all requests and query types. Most database systems provide advanced graphical tools for performance monitoring and testing. For example, <a href="#filepos1995202">Figure 11.12</a> shows the graphical representation of the access plan using the Oracle 9i graphical tools. (Oracle 11g does not include this interface.)</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a id="filepos1995202"></a><strong class="calibre14">FIGURE 11.12 Oracle 9i tools for query optimization</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00461.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre6"><span class="calibre8"><span class="calibre14"><a id="filepos1995697"></a>SUMMARY</span></span></p>
<hr class="calibre10"/><p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Database performance tuning refers to a set of activities and procedures designed to ensure that an end-user query is processed by the DBMS in the least amount of time.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   SQL performance tuning refers to activities on the client side that are designed to generate SQL code that returns the correct answer in the least amount of time, using the minimum amount of resources at the server end.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   DBMS performance tuning refers to activities on the server side that are oriented so the DBMS is properly configured to respond to clients’ requests in the fastest way possible while making optimum use of existing resources.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   The DBMS architecture is represented by the many processes and structures (in memory and permanent storage) used to manage a database.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Database statistics refer to a number of measurements gathered by the DBMS that describe a snapshot of the database objects’ characteristics. The DBMS gathers statistics about objects such as tables, indexes, and available resources, which include number of processors used, processor speed, and temporary space available. The DBMS uses the statistics to make critical decisions about improving query processing efficiency.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   DBMSs process queries in three phases. In the parsing phase, the DBMS parses the SQL query and chooses the most efficient access/execution plan. In the execution phase, the DBMS executes the SQL query using the chosen execution plan. In the fetching phase, the DBMS fetches the data and sends the result set back to the client.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Indexes are crucial in the process that speeds up data access. Indexes facilitate searching, sorting, and using aggregate functions and join operations. The improvement in data access speed occurs because an index is an ordered set of values that contains the index key and pointers. Data sparsity refers to the number of different values a column could have. Indexes are recommended in high-sparsity columns used in search conditions.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   During query optimization, the DBMS must choose what indexes to use, how to perform join operations, which table to use first, and so on. Each DBMS has its own algorithms for determining the most efficient way to access the data. The two most common approaches are rule-based and cost-based optimization.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   A rule-based optimizer uses preset rules and points to determine the best approach to execute a query. The rules assign a ”fixed cost” to each SQL operation; the costs are then added to yield the cost of the execution plan.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   A cost-based optimizer uses sophisticated algorithms based on statistics about the objects being accessed to determine the best approach to execute a query. In this case, the optimizer process adds up the processing cost, the I/O costs, and the resource costs (RAM and temporary space) to determine the total cost of a given execution plan.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Hints are used to change the optimizer mode for the current SQL statement. Hints are special instructions for the optimizer that are embedded inside the SQL command text.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   SQL performance tuning deals with writing queries that make good use of the statistics. In particular, queries should make good use of indexes. Indexes are very useful when you want to select a small subset of rows from a large table based on a condition. When an index exists for the column used in the selection, the DBMS may choose to use it. The objective is to create indexes with high selectivity. Index selectivity is a measure of the likelihood that an index will be used in query processing. It is also important to write conditional statements using some common principles.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   Query formulation deals with how to translate business questions into specific SQL code to generate the required results. To do this, you must carefully evaluate which columns, tables, and computations are required to generate the desired output.</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5"><img alt="img" src="images/00030.jpg" class="calibre7"/>   DBMS performance tuning includes tasks such as managing the DBMS processes in primary memory (allocating memory for caching purposes) and managing the structures in physical storage (allocating space for the data files).</span></p><div class="calibre3"> </div>
<p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre80"><span class="calibre8"><span class="calibre14"><a id="filepos2001699"></a>KEY TERMS</span></span></p>
<hr class="calibre10"/><blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1923309">access plan</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1908055">automatic query optimization</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1938113">bitmap index</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1937388">b-tree index</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1902235">buffer cache</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1981837">clustered index table</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1941936">cost-based optimizer</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1893734">database performance tuning</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1913244">database statistics</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1902170">data cache</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1900703">data files</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1935843">data sparsity</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1898051">DBMS performance tuning</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1909517">dynamic query optimization</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1911915">dynamic statistical generation mode</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1901140">extends</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1901530">file group</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1957087">function-based index</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1936872">hash index</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1981760">index-organized table</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1954284">index selectivity</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1903747">input/output (I/O) request</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1908224">manual query optimization</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1912089">manual statistical generation mode</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1948519">optimizer hints</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1902763">procedure cache</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1921926">query optimizer</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1929209">query processing bottleneck</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1975651">RAID</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1941475">rule-based optimizer</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1912392">rule-based query optimization algorithm</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1908903">static query optimization</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1910414">statistically based query optimization algorithm</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1902698">SQL cache</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1897645">SQL performance tuning</a></span></p></blockquote>
<blockquote class="calibre38"><p class="calibre78"><span class="calibre5"><a href="#filepos1901464">table space</a></span></p></blockquote>
<hr class="calibre10"/><p class="calibre63"><span class="calibre35"><img alt="img" src="images/00023.jpg" class="calibre7"/> O<span><span class="calibre68">NLINE</span></span> C<span><span class="calibre68">ONTENT</span></span></span></p>
<p class="calibre9">Flashcards and crossword puzzles for key term practice are available at <a href="http://www.cengagebrain.com"><em class="italic">www.cengagebrain.com</em></a>.</p>
<hr class="calibre10"/><p class="calibre33"> </p>
<hr class="calibre10"/><p class="calibre6"><span class="calibre8"><span class="calibre14"><a id="filepos2008017"></a>REVIEW QUESTIONS</span></span></p>
<hr class="calibre10"/><p class="calibre79"><span class="calibre5">  1.  What is SQL performance tuning?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  2.  What is database performance tuning?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  3.  What is the focus of most performance-tuning activities, and why does that focus exist?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  4.  What are database statistics, and why are they important?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  5.  How are database statistics obtained?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  6.  What database statistics measurements are typical of tables, indexes, and resources?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  7.  How is the processing of SQL DDL statements (such as CREATE TABLE) different from the processing required by DML statements?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  8.  In simple terms, the DBMS processes a query in three phases. What are those phases, and what is accomplished in each phase?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">  9.  If indexes are so important, why not index every column in every table? (Include a brief discussion of the role played by data sparsity.)</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">10.  What is the difference between a rule-based optimizer and a cost-based optimizer?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">11.  What are optimizer hints, and how are they used?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">12.  What are some general guidelines for creating and using indexes?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">13.  Most query optimization techniques are designed to make the optimizer’s work easier. What factors should you keep in mind if you intend to write conditional expressions in SQL code?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">14.  What recommendations would you make for managing the data files in a DBMS with many tables and indexes?</span></p><div class="calibre3"> </div>
<p class="calibre79"><span class="calibre5">15.  What does RAID stand for, and what are some commonly used RAID levels?</span></p><div class="calibre3"> </div>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre6"><span class="calibre8"><span class="calibre14"><a id="filepos2010930"></a>PROBLEMS</span></span></p>
<hr class="calibre10"/><p class="calibre9"><a href="#filepos2011486">Problems 1</a> and <a href="#filepos2011671">2</a> are based on the following query:</p>
<p class="calibre9">SELECT        EMP_LNAME, EMP_FNAME, EMP_AREACODE, EMP_SEX <br class="calibre15"/>FROM           EMPLOYEE <br class="calibre15"/>WHERE         EMP_SEX = 'F' AND EMP_AREACODE = '615' <br class="calibre15"/>ORDER BY    EMP_LNAME, EMP_FNAME;</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2011486"></a>1.    What is the likely data sparsity of the EMP_SEX column?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2011671"></a>2.    What indexes should you create? Write the required SQL commands.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>3.    Using <a href="#filepos1944543">Table 11.4</a> as an example, create two alternative access plans. Use the following assumptions:</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">a.   There are 8,000 employees.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">b.   There are 4,150 female employees.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">c.   There are 370 employees in area code 615.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre38"><p class="calibre82"><span class="calibre5">d.   There are 190 female employees in area code 615.</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2013179">Problems 4</a>–<a href="#filepos2013548">6</a> are based on the following query:</p>
<p class="calibre9">SELECT         EMP_LNAME, EMP_FNAME, EMP_DOB, YEAR(EMP_DOB) AS YEAR <br class="calibre15"/>FROM            EMPLOYEE <br class="calibre15"/>WHERE         YEAR(EMP_DOB) = 1966;</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2013179"></a>4.    What is the likely data sparsity of the EMP_DOB column?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>5.    Should you create an index on EMP_DOB? Why or why not?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2013548"></a>6.    What type of database I/O operations will likely be used by the query? (See <a href="#filepos1924518">Table 11.3</a>.)</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2014663">Problems 7</a>-<a href="#filepos2015307">10</a> are based on the ER model shown in Figure P11.7 and on the query shown after the figure.</p>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre69"><span class="calibre8"><span class="calibre14"><a></a><strong class="calibre14">FIGURE P11.7 The Ch11_SaleCo ER model</strong></span></span></p><div class="calibre58"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00462.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<p class="calibre73"><span class="calibre8">SOURCE: Course Technology/Cengage Learning</span></p><div class="calibre13"> </div>
<hr class="calibre10"/><p class="calibre9">SELECT        P_CODE, P_PRICE <br class="calibre15"/>FROM           PRODUCT <br class="calibre15"/>WHERE         P_PRICE &gt;= (SELECT AVG(P_PRICE) FROM PRODUCT);</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2014663"></a>7.    Assuming there are no table statistics, what type of optimization will the DBMS use?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>8.    What type of database I/O operations will likely be used by the query? (See <a href="#filepos1924518">Table 11.3</a>.)</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>9.    What is the likely data sparsity of the P_PRICE column?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2015307"></a>10.  Should you create an index? Why or why not?</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2015880">Problems 11</a>-<a href="#filepos2016581">14</a> are based on the following query:</p>
<p class="calibre9">SELECT        P_CODE, SUM(LINE_UNITS) <br class="calibre15"/>FROM           LINE <br class="calibre15"/>GROUP BY    P_CODE <br class="calibre15"/>HAVING        SUM(LINE_UNITS) &gt; (SELECT MAX(LINE_UNITS) FROM LINE);</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2015880"></a>11.  What is the likely data sparsity of the LINE_UNITS column?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>12.  Should you create an index? If so, what would the index column(s) be, and why would you create the index? If not, explain your reasoning.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>13.  Should you create an index on P_CODE? If so, write the SQL command to create the index. If not, explain your reasoning.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2016581"></a>14.  Write the command to create statistics for this table.</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2017150">Problems 15</a> and <a href="#filepos2017345">16</a> are based on the following query:</p>
<p class="calibre9">SELECT        P_CODE, P_QOH*P_PRICE <br class="calibre15"/>FROM           PRODUCT <br class="calibre15"/>WHERE         P_QOH*P_PRICE &gt; (SELECT AVG(P_QOH*P_PRICE) FROM PRODUCT);</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2017150"></a>15.  What is the likely data sparsity of the P_QOH and P_PRICE columns?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2017345"></a>16.  Should you create an index? If so, what would the index column(s) be, and why should you create the index?</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2017945">Problems 17</a>–<a href="#filepos2019161">21</a> are based on the following query:</p>
<p class="calibre9">SELECT       V_CODE, V_NAME, V_CONTACT, V_STATE <br class="calibre15"/>FROM          VENDOR <br class="calibre15"/>WHERE        V_STATE = 'TN' ORDER BY V_NAME;</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2017945"></a>17.  What indexes should you create and why? Write the SQL command to create the indexes.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>18.  Assume that 10,000 vendors are distributed as shown in <a href="#filepos2018471">Table P11.18</a>. What percentage of rows will be returned by the query?</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre48"> </p>
<hr class="calibre10"/><p class="calibre63"><span class="calibre8"><span class="calibre14"><a id="filepos2018471"></a><strong class="calibre14">TABLE P11.18</strong></span></span></p><div class="calibre64"> </div>
<hr class="calibre10"/><p class="calibre11"><img alt="img" src="images/00463.jpg" class="calibre7"/></p><div class="calibre32"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>19.  What type of I/O database operations would most likely be used to execute the query?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>20.  Using <a href="#filepos1944543">Table 11.4</a> as an example, create two alternative access plans.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2019161"></a>21.  Assume that you have 10,000 different products stored in the PRODUCT table and that you are writing a Web-based interface to list all products with a quantity on hand (P_QOH) that is less than or equal to the minimum quantity, P_MIN. What optimizer hint would you use to ensure that your query returns the result set to the Web interface in the least time possible? Write the SQL code.</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2020179">Problems 22</a>–<a href="#filepos2020577">24</a> are based on the following query:</p>
<p class="calibre9">SELECT        P_CODE, P_DESCRIPT, P_PRICE, P.V_CODE, V_STATE <br class="calibre15"/>FROM           PRODUCT P, VENDOR V <br class="calibre15"/>WHERE        P.V_CODE = V.V_CODE <br class="calibre15"/>                       AND V_STATE = 'NY' <br class="calibre15"/>                       AND V_AREACODE = '212' <br class="calibre15"/> ORDER BY   P_PRICE;</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2020179"></a>22.  What indexes would you recommend?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a></a>23.  Write the commands required to create the indexes you recommended in <a href="#filepos2020179">Problem 22</a>.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2020577"></a>24.  Write the command(s) used to generate the statistics for the PRODUCT and VENDOR tables.</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2021182">Problems 25</a> and <a href="#filepos2021374">26</a> are based on the following query:</p>
<p class="calibre9">SELECT        P_CODE, P_DESCRIPT, P_QOH, P_PRICE, V_CODE <br class="calibre15"/>FROM           PRODUCT <br class="calibre15"/>WHERE        V_CODE = '21344' <br class="calibre15"/>ORDER BY   P_CODE;</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2021182"></a>25.  What index would you recommend, and what command would you use?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2021374"></a>26.  How should you rewrite the query to ensure that it uses the index you created in your solution to <a href="#filepos2021182">Problem 25</a>?</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2022122">Problems 27</a> and <a href="#filepos2022397">28</a> are based on the following query:</p>
<p class="calibre9">SELECT        P_CODE, P_DESCRIPT, P_QOH, P_PRICE, V_CODE <br class="calibre15"/>FROM           PRODUCT <br class="calibre15"/>WHERE        P_QOH &lt; P_MIN <br class="calibre15"/>                      AND P_MIN = P_REORDER <br class="calibre15"/>                      AND P_REORDER = 50 <br class="calibre15"/>ORDER BY   P_QOH;</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2022122"></a>27.  Use the recommendations given in <a href="#filepos1958368">Section 11.5.2</a> to rewrite the query and produce the required results more efficiently.</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2022397"></a>28.  What indexes would you recommend? Write the commands to create those indexes.</span></p></blockquote><div class="calibre3"> </div>
<p class="calibre9"><a href="#filepos2023028">Problems 29</a>–<a href="#filepos2023816">32</a> are based on the following query:</p>
<p class="calibre9">SELECT        CUS_CODE, MAX(LINE_UNITS*LINE_PRICE) <br class="calibre15"/>FROM           CUSTOMER NATURAL JOIN INVOICE NATURAL JOIN LINE <br class="calibre15"/>WHERE        CUS_AREACODE = '615' <br class="calibre15"/>GROUP BY   CUS_CODE;</p>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2023028"></a>29.  Assuming that you generate 15,000 invoices per month, what recommendation would you give the designer about the use of derived attributes?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2023295"></a>30.  Assuming that you follow the recommendations you gave in <a href="#filepos2023028">Problem 29</a>, how would you rewrite the query?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2023552"></a>31.  What indexes would you recommend for the query you wrote in <a href="#filepos2023295">Problem 30</a>, and what SQL commands would you use?</span></p></blockquote><div class="calibre3"> </div>
<blockquote class="calibre29"><p class="calibre79"><span class="calibre5"><a id="filepos2023816"></a>32.  How would you rewrite the query to ensure that the index you created in <a href="#filepos2023552">Problem 31</a> is used?</span></p></blockquote><div class="calibre3"> </div>  <div class="mbppagebreak" id="calibre_pb_28"></div></body></html>
